var documenterSearchIndex = {"docs":
[{"location":"QuantumTomography.html#Quantum-tomography-1","page":"Quantum Tomography","title":"Quantum tomography","text":"","category":"section"},{"location":"QuantumTomography.html#Initialization-1","page":"Quantum Tomography","title":"Initialization","text":"","category":"section"},{"location":"QuantumTomography.html#","page":"Quantum Tomography","title":"Quantum Tomography","text":"initializetomography","category":"page"},{"location":"QuantumTomography.html#PastaQ.initializetomography","page":"Quantum Tomography","title":"PastaQ.initializetomography","text":"initializetomography(N::Int64;kwargs...)\n\nInitialize quantum tomography given a number of qubits\n\n\n\n\n\ninitializetomography(sites::Vector{<:Index}; kwargs...)\n\nInitialize quantum tomography for a set of indices.  By default, inintializes MPS, unless ξ is non-trivial,  in which case it initializes a LPDO.\n\n\n\n\n\ninitializetomography(L::LPDO; kwargs...)\n\nInitialize quantum tomography, given a reference state, either in MPS or MPO (LPDO) form\n\n\n\n\n\ninitializetomography(sites::Vector{<:Index},χ::Int64;σ::Float64=0.1)\n\nInitialize a variational MPS for quantum tomography.\n\nArguments:\n\nN: number of qubits\nχ: bond dimension of the MPS\nσ: width of initial box distribution\n\n\n\n\n\ninitializetomography(sites::Vector{<:Index},χ::Int64,ξ::Int64;\n                     σ::Float64=0.1,purifier_tag = ts\"Purifier\")\n\nInitialize a variational LPDO for quantum tomography.\n\nArguments:\n\nN: number of qubits\nχ: bond dimension of the LPDO\nξ: local purification dimension of the LPDO\nσ: width of initial box distribution\n\n\n\n\n\n","category":"function"},{"location":"QuantumTomography.html#Tomography-1","page":"Quantum Tomography","title":"Tomography","text":"","category":"section"},{"location":"QuantumTomography.html#","page":"Quantum Tomography","title":"Quantum Tomography","text":"tomography","category":"page"},{"location":"QuantumTomography.html#PastaQ.tomography","page":"Quantum Tomography","title":"PastaQ.tomography","text":"tomography(L::LPDO, data::Array, opt::Optimizer; kwargs...)\ntomography(ψ::MPS, data::Array, opt::Optimizer; kwargs...)\n\nRun quantum state tomography using a the starting state model on data.\n\nArguments:\n\nmodel: starting LPDO state.\ndata: training data set of projective measurements.\nbatchsize: number of data-points used to compute one gradient iteration.\nepochs: total number of full sweeps over the dataset.\ntarget: target quantum state underlying the data\nchoi: if true, compute probability using Choi matrix\nobserver: keep track of measurements and fidelities.\noutputpath: write observer on file \n\n\n\n\n\ntomography(L::LPDO,data_in::Array,data_out::Array,opt::Optimizer; kwargs...)\ntomography(ψ::MPS,data_in::Array,data_out::Array,opt::Optimizer; kwargs...)\n\nRun quantum process tomography on (data_in,data_out) using model as variational ansatz.\n\nThe data is reshuffled so it takes the format: (input1,output1,input2,output2,…).\n\n\n\n\n\n","category":"function"},{"location":"QuantumTomography.html#Certification-1","page":"Quantum Tomography","title":"Certification","text":"","category":"section"},{"location":"QuantumTomography.html#","page":"Quantum Tomography","title":"Quantum Tomography","text":"fidelity\nfrobenius_distance","category":"page"},{"location":"QuantumTomography.html#PastaQ.fidelity","page":"Quantum Tomography","title":"PastaQ.fidelity","text":"fidelity(ψ::MPS,ϕ::MPS)\n\nCompute the fidelity between two MPS:\n\nF = |⟨ψ|ϕ⟩|²\n\n\n\n\n\nfidelity(ψ::MPS, ρ::LPDO)\n\nfidelity(ρ::LPDO, ψ::MPS)\n\nCompute the fidelity between an MPS and LPDO.\n\nF = ⟨ψ|ρ|ψ⟩\n\n\n\n\n\nfidelity(ψ::MPS,ρ::MPO)\n\nfidelity(ρ::MPO,ψ::MPS)\n\nCompute the fidelity between an MPS and MPO.\n\nF = ⟨ψ|ρ|ψ⟩\n\n\n\n\n\n","category":"function"},{"location":"QuantumTomography.html#PastaQ.frobenius_distance","page":"Quantum Tomography","title":"PastaQ.frobenius_distance","text":"frobenius_distance(ρ0::LPDO, σ0::LPDO)\nfrobenius_distance(ρ0::LPDO, σ0::MPO)\nfrobenius_distance(ρ0::MPO,  σ0::LPDO)\nfrobenius_distance(ρ0::MPO,  σ0::MPO)\n\nCompute the trace norm of the difference between two LPDOs and MPOs.\n\nT(ρ,σ) = sqrt(trace[(ρ-σ)†(ρ-σ)])\n\n\n\n\n\n","category":"function"},{"location":"Circuits.html#Circuit-Simulator-1","page":"Circuit Simulator","title":"Circuit Simulator","text":"","category":"section"},{"location":"Circuits.html#Initialization-1","page":"Circuit Simulator","title":"Initialization","text":"","category":"section"},{"location":"Circuits.html#","page":"Circuit Simulator","title":"Circuit Simulator","text":"qubits\nresetqubits!","category":"page"},{"location":"Circuits.html#PastaQ.qubits","page":"Circuit Simulator","title":"PastaQ.qubits","text":"qubits(N::Int; mixed::Bool=false)\n\nqubits(sites::Vector{<:Index}; mixed::Bool=false)\n\nInitialize qubits to:\n\nAn MPS wavefunction |ψ⟩ if mixed=false\nAn MPO density matrix ρ if mixed=true\n\n\n\n\n\n","category":"function"},{"location":"Circuits.html#PastaQ.resetqubits!","page":"Circuit Simulator","title":"PastaQ.resetqubits!","text":"resetqubits!(M::Union{MPS,MPO})\n\nReset qubits to the initial state:\n\n|ψ⟩=|0,0,…,0⟩ if M = MPS\nρ = |0,0,…,0⟩⟨0,0,…,0| if M = MPO\n\n\n\n\n\n","category":"function"},{"location":"Circuits.html#Running-a-quantum-circuit-1","page":"Circuit Simulator","title":"Running a quantum circuit","text":"","category":"section"},{"location":"Circuits.html#","page":"Circuit Simulator","title":"Circuit Simulator","text":"runcircuit","category":"page"},{"location":"Circuits.html#PastaQ.runcircuit","page":"Circuit Simulator","title":"PastaQ.runcircuit","text":"runcircuit(M::Union{MPS,MPO},gate_tensors::Vector{<:ITensor}; kwargs...)\n\nApply the circuit to a state (wavefunction/densitymatrix) from a list of tensors.\n\n\n\n\n\nruncircuit(M::Union{MPS,MPO},gates::Vector{<:Tuple}; noise=nothing, apply_dag=nothing, \n           cutoff=1e-15, maxdim=10000, kwargs...)\n\nApply the circuit to a state (wavefunction or density matrix) from a list of gates.\n\nIf an MPS |ψ⟩ is input, there are three possible modes:\n\nBy default (noise = nothing and apply_dag = nothing), the evolution U|ψ⟩ is performed.\nIf noise is set to something nontrivial, the mixed evolution ε(|ψ⟩⟨ψ|) is performed. Example: noise = \"AD\", γ=0.1 (amplitude damping channel with decay rate γ)\nIf noise = nothing and apply_dag = true, the evolution U|ψ⟩⟨ψ|U† is performed.\n\nIf an MPO ρ is input, there are three possible modes:\n\nBy default (noise = nothing and apply_dag = nothing), the evolution U ρ U† is performed.\nIf noise is set to something nontrivial, the evolution ε(ρ) is performed.\nIf noise = nothing and apply_dag = false, the evolution Uρ is performed.\n\n\n\n\n\nruncircuit(N::Int, gates::Vector{<:Tuple}; process=false, noise=nothing,\n           cutoff=1e-15, maxdim=10000, kwargs...)\n\nApply the circuit to a state (wavefunction or density matrix) from a list of gates, where the state has N physical qubits.  The starting state is generated automatically based on the flags process, noise, and apply_dag.\n\nBy default (noise = nothing, apply_dag = nothing, and process = false),  the evolution U|ψ⟩ is performed where the starting state is set to |ψ⟩ = |000...⟩.  The MPS U|000...⟩ is returned.\nIf noise is set to something nontrivial, the mixed evolution ε(|ψ⟩⟨ψ|) is performed,  where the starting state is set to |ψ⟩ = |000...⟩.  The MPO ε(|000...⟩⟨000...|) is returned.\nIf process = true, the evolution U 1̂ is performed, where the starting state 1̂ = (1⊗1⊗1⊗…⊗1).  The MPO approximation for the unitary represented by the set of gates is returned.  In this case, noise must be nothing.\n\n\n\n\n\nruncircuit(M::ITensor,gate_tensors::Vector{ <: ITensor};kwargs...)\n\nApply the circuit to a ITensor from a list of tensors.\n\n\n\n\n\nruncircuit(M::ITensor,gates::Vector{<:Tuple}; cutoff=1e-15,maxdim=10000,kwargs...)\n\nApply the circuit to a ITensor from a list of gates.\n\n\n\n\n\n","category":"function"},{"location":"Circuits.html#Choi-matrix-1","page":"Circuit Simulator","title":"Choi matrix","text":"","category":"section"},{"location":"Circuits.html#","page":"Circuit Simulator","title":"Circuit Simulator","text":"choimatrix","category":"page"},{"location":"Circuits.html#PastaQ.choimatrix","page":"Circuit Simulator","title":"PastaQ.choimatrix","text":"choimatrix(N::Int, gates::Vector{<:Tuple}; noise=nothing, apply_dag=false,\n           cutoff=1e-15, maxdim=10000, kwargs...)\n\nCompute the Choi matrix Λ from a set of gates that make up a quantum process.\n\nIf noise = nothing (the default), for an N-qubit process, by default the square  root of the Choi matrix |U⟩ is returned, such that the Choi matrix is the rank-1 matrix  Λ = |U⟩⟨U|. |U⟩ is an MPS with 2N sites for a process running on N physical qubits.  It is the \"state\" version of the unitary approximation for the full gate evolution U.\n\nIf noise != nothing, an approximation for the Choi matrix is returned as an MPO  with 2N sites, for a process with N physical qubits.\n\nIf noise = nothing and apply_dag = true, the Choi matrix Λ is returned as an MPO with  2N sites. In this case, the MPO Λ is equal to |U⟩⟨U|.\n\n\n\n\n\n","category":"function"},{"location":"Optimizers.html#Optimizers-1","page":"Optimizers","title":"Optimizers","text":"","category":"section"},{"location":"Optimizers.html#Stochastic-gradient-descent-1","page":"Optimizers","title":"Stochastic gradient descent","text":"","category":"section"},{"location":"Optimizers.html#","page":"Optimizers","title":"Optimizers","text":"SGD\nupdate!(::LPDO,::Array,::SGD; kwargs...)","category":"page"},{"location":"Optimizers.html#PastaQ.SGD","page":"Optimizers","title":"PastaQ.SGD","text":"SGD(L::LPDO;η::Float64=0.01,γ::Float64=0.0)\n\nStochastic gradient descent with momentum.\n\nParameters\n\nη: learning rate\nγ: friction coefficient\nv: \"velocity\"\n\n\n\n\n\n","category":"type"},{"location":"Optimizers.html#PastaQ.update!-Tuple{LPDO,Array,SGD}","page":"Optimizers","title":"PastaQ.update!","text":"update!(L::LPDO,∇::Array,opt::SGD; kwargs...)\n\nUpdate parameters with SGD.\n\nvⱼ = γ * vⱼ - η * ∇ⱼ: integrated velocity\nθⱼ = θⱼ + vⱼ: parameter update\n\n\n\n\n\n","category":"method"},{"location":"Optimizers.html#Adagrad-1","page":"Optimizers","title":"Adagrad","text":"","category":"section"},{"location":"Optimizers.html#","page":"Optimizers","title":"Optimizers","text":"AdaGrad\nupdate!(::LPDO,::Array,::AdaGrad; kwargs...)","category":"page"},{"location":"Optimizers.html#PastaQ.AdaGrad","page":"Optimizers","title":"PastaQ.AdaGrad","text":"AdaGrad(L::LPDO;η::Float64=0.01,ϵ::Float64=1E-8)\n\nParameters\n\nη: learning rate\nϵ: shift \n∇²: square gradients (running sums)\n\n\n\n\n\n","category":"type"},{"location":"Optimizers.html#PastaQ.update!-Tuple{LPDO,Array,AdaGrad}","page":"Optimizers","title":"PastaQ.update!","text":"update!(L::LPDO,∇::Array,opt::AdaGrad; kwargs...)\n\nupdate!(ψ::MPS,∇::Array,opt::AdaGrad; kwargs...)\n\nUpdate parameters with AdaGrad.\n\ngⱼ += ∇ⱼ²: running some of square gradients\nΔθⱼ = η * ∇ⱼ / (sqrt(gⱼ+ϵ) \nθⱼ = θⱼ - Δθⱼ: parameter update\n\n\n\n\n\n","category":"method"},{"location":"Optimizers.html#Adadelta-1","page":"Optimizers","title":"Adadelta","text":"","category":"section"},{"location":"Optimizers.html#","page":"Optimizers","title":"Optimizers","text":"AdaDelta\nupdate!(::LPDO,::Array,::AdaDelta; kwargs...)","category":"page"},{"location":"Optimizers.html#PastaQ.AdaDelta","page":"Optimizers","title":"PastaQ.AdaDelta","text":"AdaDelta(L::LPDO;γ::Float64=0.9,ϵ::Float64=1E-8)\n\nParameters\n\nγ: friction coefficient\nϵ: shift \n∇²: square gradients (decaying average)\nΔθ²: square updates (decaying average)\n\n\n\n\n\n","category":"type"},{"location":"Optimizers.html#PastaQ.update!-Tuple{LPDO,Array,AdaDelta}","page":"Optimizers","title":"PastaQ.update!","text":"update!(L::LPDO,∇::Array,opt::AdaDelta; kwargs...)\n\nupdate!(ψ::MPS,∇::Array,opt::AdaDelta; kwargs...)\n\nUpdate parameters with AdaDelta\n\ngⱼ = γ * gⱼ + (1-γ) * ∇ⱼ²: decaying average\nΔθⱼ = ∇ⱼ * sqrt(pⱼ) / sqrt(gⱼ+ϵ) \nθⱼ = θⱼ - Δθⱼ: parameter update\npⱼ = γ * pⱼ + (1-γ) * Δθⱼ²: decaying average\n\n\n\n\n\n","category":"method"},{"location":"Optimizers.html#Adam-1","page":"Optimizers","title":"Adam","text":"","category":"section"},{"location":"Optimizers.html#","page":"Optimizers","title":"Optimizers","text":"Adam\nupdate!(::LPDO,::Array,::Adam; kwargs...)","category":"page"},{"location":"Optimizers.html#PastaQ.Adam","page":"Optimizers","title":"PastaQ.Adam","text":"Adam(L::LPDO;η::Float64=0.001,\n     β₁::Float64=0.9,β₂::Float64=0.999,ϵ::Float64=1E-7)\n\nAdam(ψ::MPS;η::Float64=0.001,\n     β₁::Float64=0.9,β₂::Float64=0.999,ϵ::Float64=1E-7)\n\nParameters\n\nη: learning rate\nβ₁: decay rate 1 \nβ₂: decay rate 2\nϵ: shift \n∇: gradients (decaying average)\n∇²: square gradients (decaying average)\n\n\n\n\n\n","category":"type"},{"location":"Optimizers.html#PastaQ.update!-Tuple{LPDO,Array,Adam}","page":"Optimizers","title":"PastaQ.update!","text":"update!(L::LPDO,∇::Array,opt::Adam; kwargs...)\n\nupdate!(ψ::MPS,∇::A0rray,opt::Adam; kwargs...)\n\nUpdate parameters with Adam\n\n\n\n\n\n","category":"method"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"(Image: alt text) (Image: Tests) (Image: codecov) (Image: ) (Image: ) (Image: License) (Image: arXiv)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"PLEASE NOTE THIS IS PRE-RELEASE SOFTWARE      ","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"EXPECT ROUGH EDGES AND BACKWARD INCOMPATIBLE UPDATES","category":"page"},{"location":"index.html#A-Package-for-Simulation,-Tomography-and-Analysis-of-Quantum-Computers-1","page":"Introduction","title":"A Package for Simulation, Tomography and Analysis of Quantum Computers","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"PastaQ is a julia package for simulation and benchmarking of quantum computers using a combination of machine learning and tensor-network algorithms.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The main features of PastaQ are:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Simulation of quantum circuits. The package provides a simulator based on Matrix Product States (MPS) to simulate quantum circuits compiled into a set of quantum gates. Noisy circuits are simulated by specifying a noise model of interest, which is applied to each quantum gate.\nQuantum state tomography. Data-driven reconstruction of an unknown quantum wavefunction or density operators, learned respectively with an MPS and a Locally-Purified Density Operator (LPDO). The reconstruction can be certified by fidelity measurements with the target quantum state (if known, and if it admits an efficient tensor-network representation).\nQuantum process tomography. Data-driven reconstruction of an unknown quantum channel, characterized in terms of its Choi matrix (using a similar approach to quantum state tomography). The channel can be unitary (i.e. rank-1 Choi matrix) or noisy.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"PastaQ is developed at the Center for Computational Quantum Physics of the Flatiron Institute, and it is supported by the Simons Foundation.","category":"page"},{"location":"index.html#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The PastatQ package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"~ julia","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"julia> ]\n\npkg> add github.com/GTorlai/PastaQ.jl","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"Please note that right now, PastaQ.jl requires that you use Julia v1.4 or later.","category":"page"},{"location":"index.html#Documentation-1","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"STABLE –  documentation of the most recently tagged version.\nDEVEL – documentation of the in-development version.","category":"page"},{"location":"index.html#Code-Overview-1","page":"Introduction","title":"Code Overview","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The algorithms implemented in PastaQ rely on a tensor-network representation of quantum states, quantum circuits and quantum channels, which is provided by the ITensor package.","category":"page"},{"location":"index.html#Simulation-of-quantum-circuits-1","page":"Introduction","title":"Simulation of quantum circuits","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"A quantum circuit is built out of a collection of elementary quantum gates. In PastaQ, a quantum gate is described by a data structure g = (\"gatename\",sites,params) consisting of a gatename string identifying a particular gate, a set of sites identifying which qubits the gate acts on, and a set of gate parameters params (e.g. angles of qubit rotations). A comprehensive set of gates is provided, including Pauli matrices, phase and T gates, single-qubit rotations, controlled gates, Toffoli gate and others. Additional user-specific gates can be added.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"# Building a circuit data-structure\ngates = [(\"X\" , 1),                        # Pauli X on qubit 1\n         (\"CX\", (1, 2)),                   # Controlled-X on qubits [1,2]\n         (\"Rx\", 2, (θ=0.5,)),              # Rotation of θ around X\n         (\"Rn\", 3, (θ=0.5, ϕ=0.2, λ=1.2)), # Arbitrady rotation with angles (θ,ϕ,λ)\n         (\"√SWAP\", (3, 4)],                # Sqrt Swap on qubits [2,3]\n         (\"T\" , 4)]                        # T gate on qubit 4","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"For the case of a noiseless circuit, the output quantum state (MPS) and the unitary circuit (MPO) can be obtained with the runcircuit function.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using PastaQ\n\n# Example 1a: random quantum circuit\n\nN = 4     # Number of qubits\ndepth = 4 # Depth of the circuit\n\n# Generate a random quantum circuit built out of layers of single-qubit random\n# rotations + CX gates, alternating between even and of odd layers.\ngates = randomcircuit(N,depth)\n\n# Returns the MPS at the output of the quantum circuit: `|ψ⟩ = Û|0,0,…,0⟩`\nψ = runcircuit(N,gates)\n\n# Generate the MPO for the unitary circuit:\nU = runcircuit(N,gates; process=true)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"If a noise model is provided, a local noise channel is applied after each quantum gate. A noise model is described by a string noisename identifying a set of Kraus operators, which can depend on a set of additional parameters params.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using PastaQ\n\n# Example 1b: noisy quantum circuit\n\nN = 4   # Number of qubits\ndepth=4 # Depth of the quantum circuit\ngates = randomcircuit(N,depth) # random circuit\n\n# Run the circuit using an amplitude damping channel with decay rate `γ=0.01`.\n# Returns the MPO for the mixed density operator `ρ = ε(|0,0,…⟩⟨0,0,̇…|), where\n# `ε` is the quantum channel.\nρ = runcircuit(N,gates; noise=\"AD\", γ=0.01)","category":"page"},{"location":"index.html#Choi-matrix-1","page":"Introduction","title":"Choi matrix","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The Choi matrix provides a complete description of an arbitrary quantum channel. It is obtained by applying a given channel ε to half of N pairs of entangled states. If the channel ε is unitary, the Choi matrix has rank 1 Λ = |U⟩⟩⟨⟨U|, where U is the unitary circuit and |U⟩⟩ is an MPS obtained by bending the inpupt wires of the circuit MPO. If the channel is noisy, the Choi matrix is described by a MPO.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using PastaQ\n\n# Example 1c: choi matrix\n\nN = 4   # Number of qubits\ndepth=4 # Depth of the quantum circuit\ngates = randomcircuit(N,depth) # random circuit\n\n# Compute MPS for rank-1 Choi matrix of a unitary channel\n|U⟩⟩ = choimatrix(N,gates)\n\n# Compute the MPO for Choi matrix of a noisy channel\nΛ = choimatrix(N,gates; noise=\"AD\", γ=0.01)\n","category":"page"},{"location":"index.html#Data-generation-1","page":"Introduction","title":"Data generation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using PastaQ\n\n# Example 2: generation of measurement data\n\n# Set parameters\nN = 4                          # Number of qubits\ndepth = 4                      # Depth of random circuit\nnshots = 1000                  # Number of measurements\ngates = randomcircuit(N,depth) # Build gates\n\n\n# 2a) Output state of a noiseless circuit. By default, each projective measurement\n# is taken in basis randomly drawn from the the Pauli group. Also returns the output MPS.\nψ,data = generatedata(N,gates,nshots; return_state=true)\n\n#  Note: the above is equivalent to:\n# > bases = randombases(N,nshots; localbasis=[\"X\",\"Y\",\"Z\"])\n# > ψ = runcircuit(N,gates)\n# > data = generatedata(ψ,bases)\n\n# 2b) Output state of a noisy circuit. Also returns the output MPO\nρ,data = generatedata(N,gates,nshots; noise=\"AD\", γ=0.01, return_state=true)\n\n# 2c) Generate data for quantum process tomography, consisting of input states\n# (data_in) to a quantum channel, and the corresponding projective measurements\n# at the output. By defaul, the states prepared at the inputs are selected from\n# product states of eigenstates of Pauli operators, while measurements bases are\n# sampled from the Pauli group.\n\n# Unitary channel, returns the (rank-1) Choi matrix (as MPS)\nΓ,data_in,data_out=generatedata(N,gates,nshots; process=true, return_state=true)\n\n# Noisy channel, returns the Choi matrix as MPO\nΛ,data_in,data_out=generatedata(N,gates,nshots;process=true,noise=\"AD\",γ=0.01,\n                                return_state=true)","category":"page"},{"location":"index.html#Quantum-tomography-1","page":"Introduction","title":"Quantum tomography","text":"","category":"section"}]
}
