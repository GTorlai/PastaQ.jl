var documenterSearchIndex = {"docs":
[{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"EditURL = \"https://github.com/GTorlai/PastaQ.jl/blob/master/examples/src/optimal-coherent-control.jl\"","category":"page"},{"location":"examples/optimal-coherent-control.html#Optimal-Coherent-Control-1","page":"Optimal coherent control","title":"Optimal Coherent Control","text":"","category":"section"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"Quantum computers perform computations by executing circuits consisting of a set of quantum gates, and recording measurement at its output. At this level of abstraction, quantum gates are well-defined mathematical operations on a n-qubit Hilbert space. In practice, different hardware realizations engineer a universal set of gates through ia variety of controllable sets of physical interactions between the qubits. Optimal coherent control (OCC) provides is a framework whereby qubit control functions can be optimized to produce a desired target quantum gate.","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"In this tutorial example, we consider a very simple system made out of only two qubits, described by the Hamiltonian","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"H_0 = sum_j=12omega_j a^dagger_ja_j + g (a^dagger_1a_2 + a_1 a^dagger_2)","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"where omega_j are the frequencies of the transmons and g is the qubit exchange coupling.","category":"page"},{"location":"examples/optimal-coherent-control.html#Trotter-simulation-of-quantum-dynamics-1","page":"Optimal coherent control","title":"Trotter simulation of quantum dynamics","text":"","category":"section"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"Before considering the gate optimization, we first need to simulate the dynamics of the system generate by the Hamiltonian H. We begin by importing the relevant packages and setting up the simulation parameters:","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"using Random\nusing ITensors\nusing PastaQ\nusing Observers\nusing DataFrames\nusing Plots\n\nGHz = 2π\nMHz = 1e-3 * GHz\nplot_args = (\n  dpi=1000, size=(600, 300), margin=5Plots.mm, marker=:circle, markersize=2, linewidth=1\n)\n\nn = 2            # number of qubits\ng = 12 * MHz     # exchange interaction\nω₁ = 5.0 * GHz    # qubit-1 frequency\nω₂ = 5.0 * GHz    # qubit-2 frequency\nω⃗ = [ω₁, ω₂]\n\nq₁, q₂ = 1, 2         # modes ordering\nmodes = [\"q₁\", \"q₂\"]  # modes labels\n\n#generate the Hilbert space\nhilbert = qubits(n)","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"Now that we have created the Hilbert space and set the parameters, we can define the Hamiltonian. For now, we define it as a Vector of Tuple, where each Tuple represent a term in the Hamiltonian. This would be normally defined as an ITensor object (OpSum), but that is not yet fully differentiable.","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"function hamiltonian(ω⃗::Vector, g::Number)\n  H = Tuple[]\n  ω₁, ω₂ = ω⃗\n  H = vcat(H, [(ω₁, \"a† * a\", q₁)])\n  H = vcat(H, [(ω₂, \"a† * a\", q₂)])\n  H = vcat(H, [(g, \"a†b + ab†\", (q₁, q₂))])\n  return H\nend\n\nH = hamiltonian(ω⃗, g)","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"We would like to simulate the system dynamics and record measurements, such as the average mode occupation. We use the Observers.jl package to keep track of observables. The Observer object is a container of a set of Function, which are called iteratively inside whatever iterative loop we consider. We also need to add a Function that measure the average occupation here.","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"function population(ψ::MPS, site::Int)\n  s = siteinds(ψ)[site]\n  orthogonalize!(ψ, site)\n  norm2_ψ = norm(ψ)^2\n  val = scalar(ψ[site] * op(\"a† * a\", s) * dag(prime(ψ[site], s))) / norm2_ψ\n  return real(val)\nend;\n\n#define a vector of observables and create the `Observer`.\nobservables = [\"n($α)\" => x -> population(x, k)  # actually x -> expect(x, \"a† * a\"; sites = k)\n               for (k, α) in enumerate(modes)]\nobs = Observer(observables)","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"We are not ready to simulate the system dynamics using a Trotter expansion. The time-evolution propagator up to time t is decomposed as","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"U(t) = U(delta t)^M","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"with t_g = Mdelta t being the finla time. Each elementary propagator is then approximated with its Trotter expansion (to order 2 by default):","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"U(delta t) approx U_K(delta t)dots U_2(delta t) U_1(delta t)","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"tg = 30                  # final time (in ns)\ntrottersteps = 100       # number of Trotter steps\nδt = tg / trottersteps   # step size\nts = 0.0:δt:tg           # time list\n\n#build the Trotter circuit\ncircuit = trottercircuit(H; ts=ts, layered=true)\n\n#set initial state |ψ⟩ = |1,0⟩\nψ₀ = productstate(hilbert, [1, 0])\n\n#perform TEBD simulation and generate output `MPS`\nψ = runcircuit(\n  ψ₀, circuit; (observer!)=obs, move_sites_back_before_measurements=true, outputlevel=0\n)","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"The measurements taken during the dynamics (one at each Trotter layer) are store in the Observer and can be retrieved into a DataFrame format (for example). We plot here the average occupation of the two modes as a function of time:","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"res = DataFrame(results(obs));\np = plot(; xlabel=\"time (ns)\", ylabel=\"n̂(t)\", legend=(0.40, 0.9), plot_args...)\np = plot!(p, ts, res[!, \"n(q₁)\"]; label=\"n(q₁)\", plot_args...)\np = plot!(p, ts, res[!, \"n(q₂)\"]; label=\"n(q₂)\", plot_args...)\np","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"In this simulation we placed the two qubits on resonance (omega_1=omega_2). By populating one of the qubit with an excitation (qubit 1 above), we observe that the dynamics swaps the excitation between the two qubits at time. In fact, this system implements a perfect iSwap gate.","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"In practice, in idle mode the two qubits are placed at some detuning, and placed on resonance only when realizing the gate. Here we consider this setting, and we will optimize the modulation of the two qubit frequencies to realize the gate when starting further apart. But first let's just re-run the previous dynamical simulation in this setup:","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"ω₁ = 5.0 * GHz\nω₂ = 5.3 * GHz\nω⃗ = [ω₁, ω₂]\n\nH = hamiltonian(ω⃗, g)\n\nobs = Observer(observables)\n\ncircuit = trottercircuit(H; ts=ts, layered=true)\n\nψ₀ = productstate(hilbert, [1, 0])\n\nψ = runcircuit(\n  ψ₀, circuit; (observer!)=obs, move_sites_back_before_measurements=true, outputlevel=0\n)\n\nres = DataFrame(results(obs));\np = plot(; xlabel=\"time (ns)\", ylabel=\"n̂(t)\", legend=(0.50, 0.9), plot_args...)\np = plot!(p, ts, res[!, \"n(q₁)\"]; label=\"n(q₁)\", plot_args...)\np = plot!(p, ts, res[!, \"n(q₂)\"]; label=\"n(q₂)\", plot_args...)\np","category":"page"},{"location":"examples/optimal-coherent-control.html#Control-optimization-1","page":"Optimal coherent control","title":"Control optimization","text":"","category":"section"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"After importing relevant packages for the optimization, we now fix the desired gate time to t_g=25`ns. We also define two control functions:","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"f_fourier(theta t) = Lambda tanh(sum_itheta_i sin(pi i t t_g))","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"and","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"f_pulse(theta t) = tanh((t - t_on)gamma) - tanh((t - t_off)gamma)","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"using Zygote\nusing OptimKit\nusing StatsBase: mean\n\ntg = 25\ntrottersteps = 100\nδt = tg / trottersteps\nts = 0.0:δt:tg\n\nΛ = 20.0 * MHz\nfourier_control(ϑ, t) = Λ * tanh(sum([ϑ[i] * sin(π * i * t / tg) for i in 1:length(ϑ)]))\n\nfunction pulse_control(ϑ, t)\n  y₀, ypulse, ton, toff, γ = ϑ\n  f = tanh((t - ton) / γ) - tanh((t - toff) / γ)\n  return y₀ + 0.5 * (ypulse - y₀) * f\nend","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"We define the new Hamiltonian as follows. We take qubit 2 and send a pulse to bring its frequency near omega_1. At the same time, we also introduce a frequency modulation omega_1(t) with small amplitude.","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"function hamiltonian(θ⃗::Vector, ω⃗::Vector, g::Number, t::Float64)\n  ω₁, ω₂ = ω⃗\n  ϑ₁, ϑ₂ = θ⃗\n  H = Tuple[]\n  H = vcat(H, [(ω₁ + fourier_control(ϑ₁, t), \"a† * a\", q₁)])\n  H = vcat(H, [(ω₂ + pulse_control(ϑ₂, t), \"a† * a\", q₂)])\n  H = vcat(H, [(g, \"a†b + ab†\", (q₁, q₂))])\n  return H\nend\n\nhamiltonian(θ::Vector, t::Float64) = hamiltonian(θ, ω⃗, g, t);\nnothing #hide","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"Let's see how this look like:","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"Random.seed!(12345)\nNtones = 8\nϑ₁ = rand(Ntones)\nϑ₂ = [0.0, ω₁ - ω₂, 0.1 * tg, 0.9 * tg, 1]\nθ⃗₀ = [ϑ₁, ϑ₂]\np = plot(; xlabel=\"time (ns)\", ylabel=\"ωⱼ(t)\", title=\"\", legend=(0.50, 0.9), plot_args...)\np = plot!(\n  p, ts, [ω₁ + fourier_control(ϑ₁, t) for t in ts] ./ GHz; label=\"ω₁(t)\", plot_args...\n)\np = plot!(\n  p, ts, [ω₂ + pulse_control(ϑ₂, t) for t in ts] ./ GHz; label=\"ω₂(t)\", plot_args...\n)\np","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"The cost function to our optimization is computed from the inner products between the time-evolved and the desired wavefunctions:","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"C(theta) = 1 - frac1D^2bigg sum_ilanglephi_iUpsi_iranglebigg^2","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"function loss(Ψ⃗, Φ⃗, θ⃗)\n  #build sequence Tuple (OpSum) Hamiltonians at different times\n  Ht = [hamiltonian(θ⃗, t) for t in ts]\n  #Trotter-Suzuki decomposition\n  circuit = trottercircuit(Ht; ts=ts)\n  #run the circuit\n  UΨ⃗ = [runcircuit(ψ, circuit; cutoff=1e-7) for ψ in Ψ⃗]\n  #compute inner product ⟨ϕ|ψ(t)⟩\n  ip = [inner(ϕ, ψ) for (ϕ, ψ) in zip(Φ⃗, UΨ⃗)]\n  return 1 - abs2(mean(ip))\nend;\nnothing #hide","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"We not set the ideal gate (Lazy format) and define loss closure.","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"ideal_gate = [\n  [0, 0] => (1, [0, 0]),\n  [1, 0] => (-im, [0, 1]),\n  [0, 1] => (-im, [1, 0]),\n  [1, 1] => (1, [1, 1]),\n]\n\nΨ⃗ = [productstate(hilbert, σ) for σ in first.(ideal_gate)]\nΦ⃗ = [ϕ * productstate(hilbert, σ) for (ϕ, σ) in last.(ideal_gate)];\nloss(θ) = loss(Ψ⃗, Φ⃗, θ)","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"We initialize the optimizer the run the optimization for 20 steps:","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"optimizer = LBFGS(; verbosity=2, maxiter=20)\nloss_n_grad(x) = (loss(x), convert(Vector, loss'(x)))\nθ⃗, fs, gs, niter, normgradhistory = optimize(loss_n_grad, θ⃗₀, optimizer)\nnormgradhistory[:, 1]","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"In markdown sections we can use markdown syntax. For example, we can","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"Ht = [hamiltonian(θ⃗, t) for t in ts]\ncircuit = trottercircuit(Ht; ts=ts, layered=true)\nψ₀ = productstate(hilbert, [1, 0])\nobservables = [\"n($α)\" => x -> population(x, k) for (k, α) in enumerate(modes)]\nobs = Observer(observables)\nψ = runcircuit(\n  ψ₀, circuit; (observer!)=obs, move_sites_back_before_measurements=true, outputlevel=0\n)\nres = DataFrame(results(obs));\np = plot(; xlabel=\"time (ns)\", ylabel=\"n̂(t)\", legend=(0.50, 0.9), plot_args...)\np = plot!(p, ts, res[!, \"n(q₁)\"]; label=\"n(q₁)\", plot_args...)\np = plot!(p, ts, res[!, \"n(q₂)\"]; label=\"n(q₂)\", plot_args...)\np","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"","category":"page"},{"location":"examples/optimal-coherent-control.html#","page":"Optimal coherent control","title":"Optimal coherent control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"quantumtomography.html#Quantum-Tomography-1","page":"Quantum tomography","title":"Quantum Tomography","text":"","category":"section"},{"location":"quantumtomography.html#","page":"Quantum tomography","title":"Quantum tomography","text":"tomography","category":"page"},{"location":"quantumtomography.html#PastaQ.tomography","page":"Quantum tomography","title":"PastaQ.tomography","text":"tomography(data::Matrix{Pair{String, Int}}, sites::Vector{<:Index};\n           method::String = \"linear_inversion\",\n           fillzeros::Bool = true,\n           trρ::Number = 1.0,\n           max_iters::Int = 10000,\n           kwargs...)\n\ntomography(data::Matrix{Pair{String,Pair{String, Int}}}, sites::Vector{<:Index};\n           method::String=\"linear_inversion\", kwargs...)\n\nRun full quantum tomography for a set of input measurement data data. If the input data consists of a list of Pair{String, Int}, it is interpreted as quantum state tomography. Each data point is a single measurement outcome, e.g. \"X\" => 1 to refer to a measurement in the X basis with binary outcome 1. If instead the input data is a collection of Pair{String,Pair{String, Int}}, it is interpreted as quantum process tomography, with each data-point corresponding to having input a given state to the channel, followed by a measurement in a basis, e.g.  \"X+\" => (\"Z\" => 0) referring to an input +rangle state, followed by a measurement in the Z basis with outcome 0.\n\nThere are three methods to perform tomography (we show state tomography here as an example):\n\nmethod = \"linear_inversion\" (or \"LI\"): optimize a variational density matrix rho (or Choi matrix)1\n\nmethod = \"least_squares\" (or \"LS\"):\nmethod = \"maximum_likelihood\" (or \"ML\"):\n\n\n\n\n\ntomography(train_data::AbstractMatrix, L::LPDO;\n           optimizer::Optimizer,\n           observer! = nothing,\n           kwargs...)\n\nRun quantum process tomography using a variational model L to fit train_data. Depending on the type of train_data, run state or process tomography (see full tomography docs for the data format).\n\nFor quantum state tomography, optimize the average Kullbach-Leibler (KL) divergence for projective measurements in a set of bases:\n\nC(theta) = -frac1Dsum_k=1^D log P(x_k^(b))\n\nwhere the cost function is computed as\n\nC(theta) = -frac1Dsum_k=1^D log langle x_kU_bpsi(theta)rangle^2\n\nfor input MPS variational wavefunction, and\n\nC(theta) = -frac1Dsum_k=1^D log langle x_kU_b rho(theta) U_b^daggerx_krangle\n\nfor input LPDO variational density operators. Here U_b is the depth-1 unitary that rotates the variational state into the measurement basis b for outcome x^(b).\n\nFor quantum process tomography, optimize the  KL divergence for the process probability distribution\n\nC(theta) = -frac1Dsum_k=1^D log P(x_k^(b)xi)\n\nwhere xi is the input state to the channel. The cost function is computed as\n\nC(theta) = -frac1Dsum_k=1^D log langle x_kU_btildePhi(theta)rangle^2\n\nfor input MPO variational unitary operator (trated as a MPS Phirangle after appropriate vectorization), and\n\nC(theta) = -frac1Dsum_k=1^D log langle xU_b tildeLambda(theta) U_b^daggerxrangle\n\nfor input LPDO variational Choi matrix. Here we refer to tildePhi and tildeLambda respectively as the projection of the unitary operator or Choi matrix into the input state xirangle to the channel.\n\nKeyword arguments:\n\ntrain_data: pairs of preparation/ (basis/outcome): (\"X+\"=>\"X\"=>0, \"Z-\"=>\"Y\"=>1, \"Y+\"=>\"Z\"=>0, …).\nL: variational model (MPO/LPDO).\noptimizer: optimizer object for stochastic optimization (from Optimisers.jl).\nobserver!: if provided, keep track of training metrics (from Observers.jl).\nbatch_size: number of samples used for one gradient update.\nepochs: number of training iterations.\ntarget: target quantum state/process for distance measures (e.g. fidelity).\ntest_data: data for computing cross-validation.\nobserver_step = 1: how often the Observer is called to record measurements.\noutputlevel = 1: amount of information printed on screen during training.\noutputpath: if provided, save metrics on file.\nsavestate: if true, save the variational state on file.\nprint_metrics = []: print these metrics on screen during training.\nearlystop: if true, use pre-defined early-stop function. A function can also be passed  as earlystop, in which case if the function (evaluated at each iteration) returns true,  the training is halted.\n\n\n\n\n\n","category":"function"},{"location":"quantumstates.html#Quantum-States-1","page":"Quantum states","title":"Quantum States","text":"","category":"section"},{"location":"quantumstates.html#Hilbert-spaces-1","page":"Quantum states","title":"Hilbert spaces","text":"","category":"section"},{"location":"quantumstates.html#","page":"Quantum states","title":"Quantum states","text":"qubits\nqudits","category":"page"},{"location":"quantumstates.html#PastaQ.qubits","page":"Quantum states","title":"PastaQ.qubits","text":"qubits(n::Int)\n\nGenerate a n-qubit Hilbert space spanned by a basis sigma_j_j=1^n. Each local degree of freedom is represented by an ITensors.Index object, which encode the local Hilbert space dimension and a unique identifier for automated tensor contractions.\n\nq = qubits(3)\n# 3-element Vector{ITensors.Index{Int64}}:\n#  (dim=2|id=114|\"Qubit,Site,n=1\")\n#  (dim=2|id=142|\"Qubit,Site,n=2\")\n#  (dim=2|id=830|\"Qubit,Site,n=3\")\n\n\n\n\n\n","category":"function"},{"location":"quantumstates.html#PastaQ.qudits","page":"Quantum states","title":"PastaQ.qudits","text":"qudits(n::Int; dim::Int = 3)\nqudits(d⃗::Vector)\n\nGenerate a n-qudit Hilbert space spanned by a basis sigma_j_j=1^n. Each local degree of freedom is represented by an ITensors.Index object with dimension d_j. Accepted inputs are either the number of qudits (with the same local dimension d), or a vector of local dimensions mathrmd=(d_1dotsd_n).\n\nq = qudits([3,5,3])\n# 3-element Vector{ITensors.Index{Int64}}:\n#  (dim=3|id=639|\"Qudit,Site,n=1\")\n#  (dim=5|id=212|\"Qudit,Site,n=2\")\n#  (dim=3|id=372|\"Qudit,Site,n=3\")\n\n\n\n\n\n","category":"function"},{"location":"quantumstates.html#Product-states-1","page":"Quantum states","title":"Product states","text":"","category":"section"},{"location":"quantumstates.html#","page":"Quantum states","title":"Quantum states","text":"productstate","category":"page"},{"location":"quantumstates.html#PastaQ.productstate","page":"Quantum states","title":"PastaQ.productstate","text":"productstate(hilbert::Vector{<:Index})\nproductstate(n::Int; dim = 2)\n\nGenerate an MPS wavefunction correponsponding to the product state\n\npsirangle = 0rangle_1otimes0rangle_2otimesdots0rangle_n\n\nIt accepts both a Hilbert space or the number of modes and local dimension.\n\n\n\n\n\nproductstate(N::Int, states::Vector{T})\nproductstate(hilbert::Vector{<:Index}, states::Vector{T})\n\nGenerate an MPS wavefunction for a given input product state states. The state T can be specified either with bit values psirangle = 1rangleotimes0rangleotimes1rangle\n\nψ = productstate(q, [1,0,1])\n# MPS\n# [1] ((dim=2|id=717|\"Qubit,Site,n=1\"),)\n# [2] ((dim=2|id=89|\"Qubit,Site,n=2\"),)\n# [3] ((dim=2|id=895|\"Qubit,Site,n=3\"),)\n\nor with String psirangle = +rangleotimes0rangleotimes-irangle\n\nψ = productstate(q, [\"X+\",\"Z+\",\"Y-\"]);\n\n\n\n\n\n","category":"function"},{"location":"quantumstates.html#","page":"Quantum states","title":"Quantum states","text":"By default, the product states that can be built ouf ot the box are based on the single-qubit Pauli eigenstates 0rangle1rangle+rangle-rangleirangle-irangle. A different set of elementary quantum states can be easily defined as follows:","category":"page"},{"location":"quantumstates.html#","page":"Quantum states","title":"Quantum states","text":"import ITensors: state\nstate(::StateName\"mystate\", ::SiteType\"Qubit\") = [1/√3, √2/√3]","category":"page"},{"location":"quantumstates.html#Random-states-1","page":"Quantum states","title":"Random states","text":"","category":"section"},{"location":"index.html#PastaQ:-design-and-benchmarking-quantum-hardware-1","page":"Home","title":"PastaQ: design and benchmarking quantum hardware","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"PastaQ.jl is a Julia software toolbox providing a range of computational  methods for quantum computing applications. Some examples are the simulation of quancum circuits, the design of quantum gates, noise characterization and performance benchmarking. PastaQ relies on tensor-network representations of quantum states and processes, and borrows well-refined techniques from the field of machine learning and data science, such as probabilistic modeling and automatic differentiation.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Install-1","page":"Home","title":"Install","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"The PastaQ package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"julia> ]\n\npkg> add PastaQ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"PastaQ.jl relies on the following packages: ITensors.jl for low-level tensor-network algorithms, Optimisers.jl for stochastic optimization methods, Zygote.jl for automatic differentiation, and Observers.jl for tracking/recording metrics and observables. Please note that right now, PastaQ.jl requires that you use Julia v1.6 or later. ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Getting-started-1","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"In this simple example, we show how to build and run a quantum circuit to generate the n-qubit GHZ state","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"GHZrangle = frac1sqrt2(00dots0rangle + 11dots1rangle)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The circuit consists of a single Hadamard gate on qubit 1, followed by a set of  controlled-NOT gates between pairs of qubits.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"In PastaQ, a quantum gates is described by a data structure g = (\"gatename\", support, params),  consisting of a gate identifier gatename (String), a support (an Int for single-qubit gates  or a Tuple for multi-qubit gates), and a set of gate parameters, such as rotations angles, whenever needed.  A comprehensive set of elementary gates is provided, including Pauli operations, phase and T gates,  single-qubit rotations, controlled gates, Toffoli gate and others.  Additional user-specific gates can be easily added to this collection.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"using PastaQ\n\n# number of qubits\nn = 20\n\n# manually create a circuit to prepare GHZ state,\n# or use built-in call `circuit = ghz(n)`\ncircuit = [(\"H\", 1),]\nfor j in 1:n-1\n  circuit = [circuit; (\"CX\", (j, j+1))]\nend","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"20-element Vector{Tuple{String, Any}}:\n (\"H\", 1)\n (\"CX\", (1, 2))\n (\"CX\", (2, 3))\n ...\n (\"CX\", (18, 19))\n (\"CX\", (19, 20))","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"In order to execute a circuit, we first define the Hilbert space of  our system, and then run the circuit using the runcircuit function. While the first step is not strictly necessary (i.e. the Hilbert space is generated internally if not provided, it is best practice to do so, so that various objects can be defined on the same Hilbert space, a  requirement to be able to perform calculations (such as inner products, expectation values etc). The runcircuit function in this case generates an output MPS wavefunction corresponding to the GHZ state. ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"# run the circuit to obtain the output MPS\nhilbert = qubits(n)\nψ = runcircuit(hilbert, circuit)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"ITensors.MPS\n[1] ((dim=2|id=187|\"Qubit,Site,n=1\"), (dim=2|id=980|\"Link,n=1\"))\n[2] ((dim=2|id=845|\"Qubit,Site,n=2\"), (dim=2|id=980|\"Link,n=1\"), (dim=2|id=245|\"Link,n=1\"))\n[3] ((dim=2|id=559|\"Qubit,Site,n=3\"), (dim=2|id=245|\"Link,n=1\"), (dim=2|id=175|\"Link,n=1\"))\n...\n[19] ((dim=2|id=903|\"Qubit,Site,n=19\"), (dim=2|id=639|\"Link,n=1\"), (dim=2|id=66|\"Link,n=1\"))\n[20] ((dim=2|id=66|\"Link,n=1\"), (dim=2|id=212|\"Qubit,Site,n=20\"))","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"We can then perform a set of operations on the output MPS, such as generating a set of projective measurements in the computational basis:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"# sample projective measurements in the computational basis\ngetsamples(ψ, 5)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"5×20 Matrix{Int64}:\n1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"PastaQ also supports circuit with noisy gates. A noise model is defined in a  similar way to quantum gates, by a String identifier of the specific noise model, and additional parameters (such as noise strength etc). Here we define a depolarizing Kraus channel with different strengths for one- and two-qubit gates. By running the circuit with the keyword argument noise = noisemodel,  the corresponding Kraus operators are attached to each gate in the circuit. The output is a MPO density operator:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"# define a noise model with different error rates for\n# one- and two-qubit gates\nnoisemodel = (1 => (\"depolarizing\", (p = 0.01,)), \n              2 => (\"depolarizing\", (p = 0.05,)))\n\n# run a noisy circuit\nρ = runcircuit(hilbert, circuit; noise = noisemodel)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"ITensors.MPO\n[1] ((dim=2|id=187|\"Qubit,Site,n=1\")', (dim=2|id=187|\"Qubit,Site,n=1\"), (dim=4|id=104|\"Link,n=1\"))\n[2] ((dim=2|id=845|\"Qubit,Site,n=2\")', (dim=4|id=104|\"Link,n=1\"), (dim=2|id=845|\"Qubit,Site,n=2\"), (dim=4|id=668|\"Link,n=1\"))\n...\n[19] ((dim=2|id=903|\"Qubit,Site,n=19\")', (dim=4|id=792|\"Link,n=1\"), (dim=2|id=903|\"Qubit,Site,n=19\"), (dim=4|id=982|\"Link,n=1\"))\n[20] ((dim=4|id=982|\"Link,n=1\"), (dim=2|id=212|\"Qubit,Site,n=20\")', (dim=2|id=212|\"Qubit,Site,n=20\"))","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Citation-1","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"If you use PastaQ.jl in your work, for now please consider citing the Github page:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"@misc{pastaq,\n    title={\\mbox{PastaQ}: A Package for Simulation, Tomography and Analysis of Quantum Computers},\n    author={Giacomo Torlai and Matthew Fishman},\n    year={2020},\n    url={https://github.com/GTorlai/PastaQ.jl/}\n}","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Research-papers-using-PastaQ-1","page":"Home","title":"Research papers using PastaQ","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"If you used PastaQ.jl and your paper does not appear in this list, please let us know at info@pastaq.org.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"2022   ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"2203.04948 Fragile boundaries of tailored surface codes, O Higgott, TC Bohdanowicz, A Kubica, ST Flammia, ET Campbell.     ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"2021   ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"2106.12627 Provably efficient machine learning for quantum many-body problems, H-Y Huang, R Kueng, G Torlai, VV Albert, J Preskill.     \n2106.03769 Measurement-induced phase transition in trapped-ion circuits, S Czischek, G Torlai, S Ray, R Islam, RG Melko, Phys. Rev. A 104, 062405.       ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"2020    ","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"2009.01760 Classical variational simulation of the Quantum Approximation Optimization Algorithm, M Medvidovic and G Carleo, Nature Communication, 7, 101.    \n2006.02424 Quantum process tomography with unsupervised learning and tensor networks, G Torlai, CJ Wood, A Acharya, G Carleo, J Carrasquilla, L Aolita.   ","category":"page"},{"location":"measurements.html#Measurements-1","page":"Measurements","title":"Measurements","text":"","category":"section"},{"location":"measurements.html#Distance-measures-1","page":"Measurements","title":"Distance measures","text":"","category":"section"},{"location":"measurements.html#","page":"Measurements","title":"Measurements","text":"fidelity\nfrobenius_distance","category":"page"},{"location":"measurements.html#PastaQ.fidelity","page":"Measurements","title":"PastaQ.fidelity","text":"fidelity(ψ::MPS, ϕ::MPS; kwargs...)\n\nQuantum state fidelity between two wavefunctions:\n\nF(psiphi) = langlephipsirangle^2\n\n\n\n\n\nfidelity(ψ::MPS, ρ::MPO; kwargs...)\nfidelity(ρ::MPO, ψ::MPS; kwargs...)\n\nQuantum state fidelity between an MPS wavefunction and an MPO density operator:\n\nF(psirho) = langlepsirhopsirangle\n\n\n\n\n\nfidelity(Ψ::MPS, ϱ::LPDO{MPO}; cutoff::Float64 = 1e-15)\nfidelity(ϱ::LPDO{MPO}, ψ::MPS; kwargs...)\n\nQuantum state fidelity between an MPS wavefunction and a LPDO density operator varrho=XX^dagger\n\nF(psirho) = langlepsivarrhopsirangle = X^daggerpsirangle^2\n\n\n\n\n\nfidelity(A::MPO, B::MPO; process::Bool = false, cutoff::Float64 = 1e-15)\n\nFidelity F between two MPOs A and B. Implements the following:\n\nIf A and B are density operators, F is the full quantum state fidelity\n\nF(rhosigma) = Big(textTrsqrtsqrtrhosigmasqrtrhoBig)^2\n\nNote: this scales exponentially with the number n of qubits, as it involves a full diagonalization.\n\nIf A and B are unitary operators (i.e. rank-1 channels) and process = true,\n\nF is the process fidelity\n\nF = 2^-2n textTr(A^dagger B) = 2^-2n langlePhi_APhi_Brangle^2\n\nwhere Phi_jrangle = jranglerangle is the MPS corresponding to the vectorization of the unitary operator.\n\nIf A is a Choi matrix and B is a unitary operator (or viceversa), return the process fidelity\n\nF = 2^-2n textTr(A Phi_BranglelanglePhi_B) = langlePhi_BAPhi_Brangle\n\nIf A and B are both Choi matrices, return the full process fidelity\n\nF(AB) = 2^-2nBig(textTrsqrtsqrtABsqrtABig)^2\n\nwhich, as above, scale exponentially with n.\n\n\n\n\n\nfidelity(A::ITensor, B::ITensor)\n\nCompute the quantum fidelity between two ITensors. Wrap each one in the ITensorState and the ITensorOperator according to the index structure to allow dispatch.\n\n\n\n\n\nfidelity(A::ITensorState, B::ITensorState; kwargs...)\n\nState fidelity between two wavefunctions\n\n\n\n\n\nfidelity(A::ITensorState, B::ITensorOperator; kwargs...)\nfidelity(A::ITensorOperator, B::ITensorState; kwargs...)\n\nState fidelity between a wavefunction and a density operator\n\n\n\n\n\nfidelity(A::ITensorOperator, B::ITensorOperator; kwargs...)\n\nFidelity between two operators. Wrap the Choi type as for the TN (above)\n\n\n\n\n\n","category":"function"},{"location":"measurements.html#PastaQ.frobenius_distance","page":"Measurements","title":"PastaQ.frobenius_distance","text":"frobenius_distance(ρ::Union{MPO, LPDO}, σ::Union{MPO, LPDO})\n\nCompute the trace norm of the difference between two LPDOs or MPOs:\n\nT(rhosigma) = sqrttextTrbig(rho-sigma)^dagger(rho-sigma)big\n\n\n\n\n\n","category":"function"},{"location":"measurements.html#Projective-measurements-1","page":"Measurements","title":"Projective measurements","text":"","category":"section"},{"location":"measurements.html#","page":"Measurements","title":"Measurements","text":"fullpreparations\nfullbases\nrandompreparations\nrandombases","category":"page"},{"location":"measurements.html#PastaQ.fullpreparations","page":"Measurements","title":"PastaQ.fullpreparations","text":"fullpreparations(n::Int; local_input_states = \"Pauli\")\n\nGenerate the full set of n-qubit input states built out of a collection of D=M^n states out of M single-qubit states. Predefined options:\n\nlocal_input_states = \"Pauli\": D=6^n Pauli eigenstates\nlocal_input_states = \"Tetra\": D=4^n 1-qubit SIC-POVM\n\n\n\n\n\n","category":"function"},{"location":"measurements.html#PastaQ.fullbases","page":"Measurements","title":"PastaQ.fullbases","text":"fullbases(n::Int; local_basis = \"Pauli\")\n\nGenerate the full set of measurement bases for a choice of local single-qubit basis set. Predefined option:\n\nlocal_basis = \"Pauli\": set of 3^n Pauli measurement bases\n\n\n\n\n\n","category":"function"},{"location":"measurements.html#PastaQ.randompreparations","page":"Measurements","title":"PastaQ.randompreparations","text":"randompreparations(n::Int, npreps::Int;\n                   local_input_state = \"Pauli\")\n\nGenerate npreps random input states to a quantum circuit. Each n-qubit input state is selected according to the following options:\n\nlocal_input_states = \"Pauli\": D=6^n Pauli eigenstates\nlocal_input_states = \"Tetra\": D=4^n 1-qubit SIC-POVM\n\nThe input states can also be set to a user-defined set, local_input_states = [\"A\",\"B\",\"C\",...], assuming single-qubit states Arangle, Brangle have been properly defined.\n\n\n\n\n\n","category":"function"},{"location":"measurements.html#PastaQ.randombases","page":"Measurements","title":"PastaQ.randombases","text":"randombases(n::Int, nbases::Int; local_basis = \"Pauli\")\n\nGenerate nbases measurement bases composed by n single-qubit bases. By default, each local basis is randomly selected between Pauli bases [\"X\",\"Y\",\"Z\"], with \"Z\" being the default basis where the quantum state is written.\n\nThe measurement bases can also be defined by the user, local_basis = [O1, O2,...], as long as the single-qubit Hermitian operators O_j are defined.\n\n\n\n\n\n","category":"function"},{"location":"measurements.html#","page":"Measurements","title":"Measurements","text":"getsamples","category":"page"},{"location":"measurements.html#PastaQ.getsamples","page":"Measurements","title":"PastaQ.getsamples","text":"getsamples(M::Union{MPS,MPO}, nshots::Int; kwargs...)\ngetsamples(T::ITensor, nshots::Int)\n\nPerform nshots projective measurements of a wavefunction psirangle or density operator rho in the MPS/MPO reference basis. Each measurement consists of a binary vector sigma = (sigma_1sigma_2dots), drawn from the probabilty distributions:\n\nP(sigma) = langlesigmapsirangle^2,   if M = psirangle is an MPS.\nP(sigma) = langlesigmarhosigmarangle   :  if M = rho is an MPO.\n\n\n\n\n\ngetsamples(M::Union{MPS,MPO,ITensor}, bases::Matrix::Matrix{<:String}, nshots::int; kwargs...)\ngetsamples(M::Union{MPS,MPO,ITensor}, bases::Vector{<:Vector}, nshots::Int; kwargs...) =\n\nGenerate a set of measurements acccording to a set of input bases, performing nshots measurements per basis. For a single measurement, a depth-1 unitary U is applied to the input state M according to the basis. The probability of recording outcome sigma = (sigma_1sigma_2dots) in the basis defined by U is\n\nP(sigma) = langlesigmaUpsirangle^2,   if M = psirangle is an MPS.\nP(sigma) = langlesigmaUrho U^daggersigmarangle,   if M = rho is an MPO.\n\n\n\n\n\ngetsamples(\n  M::Union{LPDO,MPO,ITensor},\n  preps::Matrix,\n  bases::Matrix,\n  nshots::Int;\n  kwargs...\n)\n\nGenerate a set of process measurement data acccording to a set of input states preps and measurement bases, performing nshots measurements per configuration. For a single measurement, the input state xirangle=otimes_jxi_jrangle is evolved according to the channel M, and then measured in a given measurement basis. The probability that the final state returns outcome sigma = (sigma_1sigma_2dots) in the basis defined by U is given by\n\nP(sigmaxi) = textTrbig(rho_xi^Totimes 1)Lambda_M big\n\nwhere rho_xi = xiranglelanglexi and Lambda_M is the Choi matrix.\n\n\n\n\n\n","category":"function"},{"location":"measurements.html#Expectation-values-1","page":"Measurements","title":"Expectation values","text":"","category":"section"},{"location":"quantumcircuits.html#Quantum-Circuits-1","page":"Quantum circuits","title":"Quantum Circuits","text":"","category":"section"},{"location":"quantumcircuits.html#Built-in-circuits-1","page":"Quantum circuits","title":"Built-in circuits","text":"","category":"section"},{"location":"quantumcircuits.html#","page":"Quantum circuits","title":"Quantum circuits","text":"ghz\nqft","category":"page"},{"location":"quantumcircuits.html#PastaQ.ghz","page":"Quantum circuits","title":"PastaQ.ghz","text":"ghz(n::Int)\n\nGenerate a list of gates for the GHZ state.\n\npsirangle = (00dots0rangle + 11dots1rangle)sqrt2\n\n\n\n\n\n","category":"function"},{"location":"quantumcircuits.html#PastaQ.qft","page":"Quantum circuits","title":"PastaQ.qft","text":"qft(n::Int; inverse::Bool = false)\n\nGenerate a list of gates for the quantum fourier transform circuit on n qubits.\n\n\n\n\n\n","category":"function"},{"location":"quantumcircuits.html#Assembling-circuits-1","page":"Quantum circuits","title":"Assembling circuits","text":"","category":"section"},{"location":"quantumcircuits.html#","page":"Quantum circuits","title":"Quantum circuits","text":"gatelayer\nrandomlayer","category":"page"},{"location":"quantumcircuits.html#PastaQ.gatelayer","page":"Quantum circuits","title":"PastaQ.gatelayer","text":"gatelayer(gatename::AbstractString, n::Int; kwargs...)\n\nCreate a uniform layer containing n identical quantum gates, idenfitied by gatename. If additional parameteres are provided, they are identically added to all gates.\n\ngatelayer(\"H\",3)\n# 3-element Vector{Tuple{String, Int64}}:\n#  (\"H\", 1)\n#  (\"H\", 2)\n#  (\"H\", 3)\n\ngatelayer(\"X\",1:2:5)\n# 3-element Vector{Tuple{String, Int64}}:\n#  (\"X\", 1)\n#  (\"X\", 3)\n#  (\"X\", 5)\n\n\n\n\n\ngatelayer(gatename::AbstractString, bonds::Vector{Vector{Int}}; kwargs...)\n\nCreate a uniform layer of multi-qubit gates over a set of bonds.\n\ngatelayer(\"CX\", [(j,j+1), j=1:2:5])\n# 3-element Vector{Tuple{String, Tuple{Int64, Int64}}}:\n#  (\"CX\", (1, 2))\n#  (\"CX\", (3, 4))\n#  (\"CX\", (5, 6))\n\n\n\n\n\n","category":"function"},{"location":"quantumcircuits.html#PastaQ.randomlayer","page":"Quantum circuits","title":"PastaQ.randomlayer","text":"randomlayer(\n  gatename::AbstractString,\n  support::Union{Int, Vector{<:Tuple}, AbstractRange};\n  rng = Random.GLOBAL_RNG,\n  kwargs...\n)\n\nGenerate a random layer built out of a set one or two qubit gates If support::Int = n, generates n single-qubit gates gatename. If support::Vector=bonds, generates a set of two-qubit gates on the couplings contained in support.\n\nrandomlayer(\"Ry\", 3)\n# 3-element Vector{Any}:\n#  (\"Ry\", 1, (θ = 0.5029516521736083,))\n#  (\"Ry\", 2, (θ = 2.5324545964433693,))\n#  (\"Ry\", 3, (θ = 2.0510824561219523,))\n\n\n\n\n\nrandomlayer(\n  gatenames::Vector{<:AbstractString},\n  support::Union{Vector{<:Int}, AbstractRange, Vector{<:Tuple}};\n  rng=Random.GLOBAL_RNG,\n  weights::Union{Nothing,Vector{Float64}} = ones(length(gatenames)) / length(gatenames),\n  kwargs...,\n)\n\nGenerate a random layer built out of one or two qubit gates, where gatenames is a set of possible gates to choose from. By default, each single gate is sampled uniformaly over this set. If weights are provided, each gate is sampled accordingly.\n\nrandomlayer([\"X\",\"Y\",\"Z\"], 3)\n# 3-element Vector{Any}:\n#  (\"Y\", 1)\n#  (\"Y\", 2)\n#  (\"X\", 3)\n\n\n\n\n\n","category":"function"},{"location":"quantumcircuits.html#Random-circuits-1","page":"Quantum circuits","title":"Random circuits","text":"","category":"section"},{"location":"quantumcircuits.html#","page":"Quantum circuits","title":"Quantum circuits","text":"randomcircuit","category":"page"},{"location":"quantumcircuits.html#PastaQ.randomcircuit","page":"Quantum circuits","title":"PastaQ.randomcircuit","text":"randomcircuit(\n  coupling_sequence::Vector;\n  depth::Int = 1,\n  twoqubitgates::Union{String,Vector{String}}=\"RandomUnitary\",\n  onequbitgates::Union{Nothing,String,Vector{String}}=nothing,\n  layered::Bool=true,\n  rng=Random.GLOBAL_RNG)\n\nBuild a circuit with given depth, where each layer consists of a set of two-qubit gates applied on pairs of qubits in according to a set of coupling_sequences. Each layer also contains n single-qubit gates. IN both cases, the chosen gates are passed as keyword arguments onequbitgates and twoqubitgates.\n\nThe default configurations consists of two-qubit random Haar unitaries, and no single-qubit gates.\n\nIf layered = true, the object returned in a Vector of circuit layers, rather than the full collection  of quantum gates.\n\n\n\n\n\nrandomcircuit(n::Int; kwargs...)\n\nOne-dimensional random quantum circuit:\n\nrandomcircuit(4; depth = 2, twoqubitgates = \"CX\", onequbitgates = \"Ry\")\n# [(\"CX\", (1, 2)),\n#  (\"CX\", (3, 4)),\n#  (\"Ry\", 1, (θ = 0.52446,)),\n#  (\"Ry\", 2, (θ = 3.01059,)),\n#  (\"Ry\", 3, (θ = 0.25144,)),\n#  (\"Ry\", 4, (θ = 1.93356,))]\n# [(\"CX\", (2, 3)),\n#  (\"Ry\", 1, (θ = 2.15460,)),\n#  (\"Ry\", 2, (θ = 2.52480,)),\n#  (\"Ry\", 3, (θ = 1.85756,)),\n#  (\"Ry\", 4, (θ = 0.02405,))]\n\n\n\n\n\nrandomcircuit(size::Tuple; rotated::Bool = false, kwargs...)\n\nTwo-dimensional random quantum circuit on a square lattice. If rotated = true, use rotated lattice of 45 degrees.\n\n\n\n\n\n","category":"function"},{"location":"quantumcircuits.html#Executing-quantum-circuits-1","page":"Quantum circuits","title":"Executing quantum circuits","text":"","category":"section"},{"location":"quantumcircuits.html#","page":"Quantum circuits","title":"Quantum circuits","text":"buildcircuit","category":"page"},{"location":"quantumcircuits.html#PastaQ.buildcircuit","page":"Quantum circuits","title":"PastaQ.buildcircuit","text":"buildcircuit(\n  hilbert::Vector{<:Index},\n  circuit::Union{Tuple, Vector{<:Any}};\n  noise::Union{Nothing, Tuple, NamedTuple} = nothing\n)\nbuildcircuit(M::Union{MPS,MPO,ITensor}, args...; kwargs...)\n\nCompile a circuit from a lazy representation into a vector of ITensor. For example, a gate element of circuit, (\"gn\", (i,j)) is turned into a rrank-4 tensor corresponding to the i and j element of hilbert.\n\nIf noise is passed, the corresponding Kraus operator are inserted appropriately after the gates in the circuit.\n\n\n\n\n\n","category":"function"},{"location":"quantumcircuits.html#","page":"Quantum circuits","title":"Quantum circuits","text":"runcircuit\nchoimatrix","category":"page"},{"location":"quantumcircuits.html#PastaQ.runcircuit","page":"Quantum circuits","title":"PastaQ.runcircuit","text":"runcircuit(circuit::Any; kwargs...)\n\nExecute quantum circuit (see below).\n\n\n\n\n\nruncircuit(hilbert::Vector{<:Index}, circuit::Tuple; kwargs...)\n\nExecute quantum circuit on Hilbert space hilbert (see below).\n\n\n\n\n\nruncircuit(hilbert::Vector{<:Index}, circuit::Vector;\n           full_representation::Bool = false,\n           process::Bool = false,\n           noise = nothing,\n           kwargs...)\n\nruncircuit(M::Union{MPS, MPO, ITensor}, circuit::Union{Tuple, AbstractVector};\n           full_representation::Bool = false, noise = nothing, kwargs...)\n\nRun the circuit corresponding to a list of quantum gates on a system of n qubits, with input Hilbert space hilbert. The specific method of this general function is specified by the keyword arguments process and noise.\n\nBy default (process = false and noise = nothing), runcircuit returns an MPS wavefunction corresponding to the contraction of each quantum gate in circuit with the zero product state\n\npsirangle = U_Mdots U_2 U_100dots0rangle\n\nIf process = true, the output is the MPO corresponding to the full unitary circuit:\n\nU = U_Mdots U_2 U_1\n\nIf noise is set to a given input noise model (in lazy representation), Kraus operators are added to each gate in the circuit, and the output is the MPO density operator given by the contraction of the noisy circuit with input zero state:\n\nrho = mathcalE(0dots0ranglelangle0dots0)\n\nFinally, if both noise = ... and proces  = true, the output is the full quantum channel, which we by default represent with its Choi matrix:\n\nLambda = (1+mathcalE)PhiranglelanglePhi^otimes n\n\nIf full_representation = true, the contraction is performed without approximation, leading to an output object whose size scales exponentiall with n\n\n\n\n\n\nruncircuit(\n  M::Union{MPS, MPO, ITensor},\n  circuit::Vector{<:Vector{<:ITensor}};\n  (observer!)=nothing,\n  move_sites_back_before_measurements::Bool=false,\n  noise = nothing,\n  outputlevel = 1,\n  outputpath = nothing,\n  savestate = false,\n  print_metrics = [],\n  kwargs...)\n\nApply a quantum circuit to an input state M, where the circuit is built out of a sequence of layers of quantum gates. The input state may be an MPS wavefunction psirangle, an MPO density operator ρ (or unitary operator U), etc.\n\nBy feeding a \"layered\" circuit, we can enable measurement and keep track of metrics as a function of the circuit's depth.\n\nOther than the keyword arguments of the high-level interface, here we can provide:\n\n(observer!): observer object (from Observers.jl).\noutputlevel = 1: amount of printing during calculation.\noutputpath = nothing: if set, save observer on file.\nsavestate = false: if true, save the MPS/MPO on file.\nprint_metrics = []: the metrics in the observed to print at each depth.`\n\n\n\n\n\nruncircuit(\n  M::Union{MPS,MPO},\n  circuit_tensors::Vector{<:ITensor};\n  apply_dag=nothing,\n  cutoff=1e-15,\n  maxdim=10_000,\n  svd_alg=\"divide_and_conquer\",\n  move_sites_back::Bool=true,\n  kwargs...)\n\nApply a set of \"gate\" tensors (alredy in the form of ITensor) to an input state M, with options:\n\napply_dag = nothing: whether to perform conjugate evolution.\ncutoff = 1e-15: truncation cutoff in SVD.\nmaxdim = 10_000: maximum bond dimension at SVD trunctions.\nsvd_alg = \"divide_and_conquer\": SVD algorithm (see ITensors.jl).\nmove_sites_back = true: move sites back after long-range gate.\n\nBy default, apply_dag = nothing and the interface is dictated by the input state, and whether or not the vector of ITensor containins rank-3 noisy tensors (i.e. Kraus operators).\n\nFor an input MPS psi_0rangle, with a unitary circuit, the output is\n\npsirangle = U_Mdots U_2 U_1psi_0rangle\n\nwhile for noisy circuits:\n\nrho = mathcalE(psi_0ranglelanglepsi_0)\n\nFor an input MPO rho_0, the output is\n\nrho = U_Mdots U_2 U_1 rho_0 U^dagger_1 U^dagger_2dotsU^dagger_M\n\nfor unitary circuits, and rho = mathcalE(rho_0) for noisy circuits.\n\n\n\n\n\n","category":"function"},{"location":"quantumcircuits.html#PastaQ.choimatrix","page":"Quantum circuits","title":"PastaQ.choimatrix","text":"choimatrix(circuit::Vector{<:Any}; kwargs...) =\nchoimatrix(sites::Vector{<:Index}, circuit::Vector{<:Any}; kwargs...)\nchoimatrix(sites::Vector{<:Index}, circuit_tensors::Vector{<:ITensor};\n           full_representation = false,kwargs...)\n\nCompute the Choi matrix for a noisy channel\n\nLambda = (1+mathcalE)PhiranglelanglePhi^otimes n\n\nIf full_representation = true, the contraction is performed without approximation, leading to an output object whose size scales exponentiall with n\n\n\n\n\n\n","category":"function"}]
}
