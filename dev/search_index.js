var documenterSearchIndex = {"docs":
[{"location":"QuantumTomography.html#Quantum-tomography-1","page":"Quantum Tomography","title":"Quantum tomography","text":"","category":"section"},{"location":"QuantumTomography.html#Tomography-1","page":"Quantum Tomography","title":"Tomography","text":"","category":"section"},{"location":"QuantumTomography.html#","page":"Quantum Tomography","title":"Quantum Tomography","text":"tomography\nsplit_dataset","category":"page"},{"location":"QuantumTomography.html#PastaQ.tomography","page":"Quantum Tomography","title":"PastaQ.tomography","text":"tomography(train_data::Matrix{Pair{String,Pair{String, Int}}}, L::LPDO;\n           optimizer::Optimizer,\n           observer! = nothing,\n           batchsize::Int64 = 100,\n           epochs::Int64 = 1000,\n           kwargs...)\n\nRun quantum process tomography using a variational model L to fit train_data. The model can be either a unitary circuit (MPO) or a Choi matrix (LPDO).\n\nArguments:\n\ntrain_data: pairs of preparation/ (basis/outcome): (\"X+\"=>\"X\"=>0, \"Z-\"=>\"Y\"=>1, \"Y+\"=>\"Z\"=>0, …).\nL: variational model (MPO/LPDO).\noptimizer: algorithm used to update the model parameters.\nobserver!: if provided, keep track of training metrics.\nbatch_size: number of samples used for one gradient update.\nepochs: number of training iterations.\ntarget: target quantum process (if provided, compute fidelities).\ntest_data: data for computing cross-validation.\noutputpath: if provided, save metrics on file.\n\n\n\n\n\n","category":"function"},{"location":"QuantumTomography.html#PastaQ.split_dataset","page":"Quantum Tomography","title":"PastaQ.split_dataset","text":"split_dataset(data::Matrix; train_ratio::Float64 = 0.9, randomize::Bool = true)\n\nSplit a data set into a train and test sets, given a train_ratio (i.e. the  percentage of data in train_data. If randomize=true (default), the data is  randomly shuffled before splitting.\n\n\n\n\n\n","category":"function"},{"location":"QuantumTomography.html#Certification-1","page":"Quantum Tomography","title":"Certification","text":"","category":"section"},{"location":"QuantumTomography.html#","page":"Quantum Tomography","title":"Quantum Tomography","text":"fidelity\nfrobenius_distance\nfidelity_bound","category":"page"},{"location":"QuantumTomography.html#PastaQ.fidelity","page":"Quantum Tomography","title":"PastaQ.fidelity","text":"fidelity(ψ::MPS, ϕ::MPS; kwargs...)\n\nQuantum state fidelity between two wavefunctions.\n\nF = |⟨ψ|ϕ⟩|²\n\n\n\n\n\nfidelity(ψ::MPS, ρ::MPO; kwargs...)\nfidelity(ρ::MPO, ψ::MPS; kwargs...)\n\nQuantum state fidelity between an MPS wavefunction and a  density operator.\n\nF = ⟨ψ|ρ|ψ⟩\n\n\n\n\n\nfidelity(Ψ::MPS, ϱ::LPDO{MPO}; cutoff::Float64 = 1e-15)\nfidelity(ϱ::LPDO{MPO}, ψ::MPS; kwargs...)\n\nQuantum state fidelity between an MPS wavefunction and a  LPDO density operator.\n\nF = ⟨ψ|ϱ|ψ⟩=|X†|ψ⟩|²\n\n\n\n\n\nfidelity(A::MPO, B::MPO; process::Bool = false, cutoff::Float64 = 1e-15)\n\nFidelity between two MPOs. If any is a Choi matrix, wrap them with the Choi type.\n\n\n\n\n\nfidelity(A::MPO, B::LPDO{MPO}; process::Bool=false, cutoff::Float64 = 1e-15)\n\nFidelity between a MPO and a LPDO. Wrap the MPO in the Choi if so.\n\n\n\n\n\nfidelity(A::LPDO{MPO}, B::LPDO{MPO}; kwargs...)\n\nQuantum fidelity between two LPDO density matrices.\n\n\n\n\n\nfidelity(A::ITensor, B::ITensor)\n\nCompute the quantum fidelity between two ITensors. Wrap each one in the ITensorState and the ITensorOperator according to the index structure to allow dispatch.\n\n\n\n\n\nfidelity(A::ITensorState, B::ITensorState; kwargs...)\n\nState fidelity between two wavefunctions\n\n\n\n\n\nfidelity(A::ITensorState, B::ITensorOperator; kwargs...)\nfidelity(A::ITensorOperator, B::ITensorState; kwargs...)\n\nState fidelity between a wavefunction and a density operator\n\n\n\n\n\nfidelity(A::ITensorOperator, B::ITensorOperator; kwargs...)\n\nFidelity between two operators. Wrap the Choi type as for the TN (above)\n\n\n\n\n\n","category":"function"},{"location":"QuantumTomography.html#PastaQ.frobenius_distance","page":"Quantum Tomography","title":"PastaQ.frobenius_distance","text":"frobenius_distance(ρ::Union{MPO, LPDO}, σ::Union{MPO, LPDO})\n\nCompute the trace norm of the difference between two LPDOs and MPOs:\n\nT(ρ,σ) = sqrt(trace[(ρ̃-σ̃)†(ρ̃-σ̃)])\n\nwhere ρ̃ and σ̃ are the normalized density matrices.\n\n\n\n\n\n","category":"function"},{"location":"QuantumTomography.html#PastaQ.fidelity_bound","page":"Quantum Tomography","title":"PastaQ.fidelity_bound","text":"fidelity_bound(ρ::Union{MPO, LPDO}, σ::Union{MPO, LPDO})\n\nCompute the the following lower bound of the fidelity:\n\nF̃(ρ,σ) = trace[ρ̃† σ̃]\n\nwhere ρ̃ and σ̃ are the normalized density matrices.\n\nThe bound becomes tight when the target state is nearly pure.\n\n\n\n\n\n","category":"function"},{"location":"Circuits.html#Circuit-Simulator-1","page":"Circuit Simulator","title":"Circuit Simulator","text":"","category":"section"},{"location":"Circuits.html#Initialization-1","page":"Circuit Simulator","title":"Initialization","text":"","category":"section"},{"location":"Circuits.html#","page":"Circuit Simulator","title":"Circuit Simulator","text":"qubits\nresetqubits!","category":"page"},{"location":"Circuits.html#Gates-and-circuits-1","page":"Circuit Simulator","title":"Gates and circuits","text":"","category":"section"},{"location":"Circuits.html#","page":"Circuit Simulator","title":"Circuit Simulator","text":"gate\nbuildcircuit","category":"page"},{"location":"Circuits.html#Running-a-quantum-circuit-1","page":"Circuit Simulator","title":"Running a quantum circuit","text":"","category":"section"},{"location":"Circuits.html#","page":"Circuit Simulator","title":"Circuit Simulator","text":"runcircuit\nPastaQ.choimatrix","category":"page"},{"location":"Circuits.html#PastaQ.runcircuit","page":"Circuit Simulator","title":"PastaQ.runcircuit","text":"runcircuit(M::Union{MPS,MPO}, gate_tensors::Vector{<:ITensor};\n           kwargs...)\n\nApply the circuit to a state (wavefunction/densitymatrix) from a list of tensors.\n\n\n\n\n\nruncircuit(N::Int, gates::Vector{<:Tuple};\n           process = false,\n           noise = nothing,\n           cutoff = 1e-15,\n           maxdim = 10000,\n           svd_alg = \"divide_and_conquer\")\n\nRun the circuit corresponding to a list of quantum gates on a system of N qubits.  The starting state is generated automatically based on the flags process, noise, and apply_dag.\n\nBy default (noise = nothing, apply_dag = nothing, and process = false),  the evolution U|ψ⟩ is performed where the starting state is set to |ψ⟩ = |000...⟩.  The MPS U|000...⟩ is returned.\nIf noise is set to something nontrivial, the mixed evolution ε(|ψ⟩⟨ψ|) is performed,  where the starting state is set to |ψ⟩ = |000...⟩.  The MPO ε(|000...⟩⟨000...|) is returned.\nIf process = true and noise = nothing, the evolution U 1̂ is performed,  where the starting state 1̂ = (1⊗1⊗1⊗…⊗1). The MPO approximation for the unitary  represented by the set of gates is returned.\nIf process = true and noise is set to something nontrivial, the function returns the Choi matrix  Λ = ε⊗1̂(|ξ⟩⟨ξ|), where |ξ⟩= ⨂ⱼ |00⟩ⱼ+|11⟩ⱼ, approximated by a MPO with 4 site indices, two for the input and two for the output Hilbert space of the quantum channel.\n\n\n\n\n\n runcircuit(M::Union{MPS, MPO}, gates::Union{Tuple,Vector{<:Any}};\n            noise = nothing, kwargs...)\n\nruncircuit(M::Union{MPS, MPO}, gates::Vector{<:Vector{<:Any}};\n           observer! = nothing, \n           move_sites_back_before_measurements::Bool = false,\n           noise = nothing,\n           kwargs...)\n\nApply a quantum circuit to a state (wavefunction or density matrix) \n\nIf an MPS |ψ⟩ is input, there are three possible modes:\n\nBy default (noise = nothing and apply_dag = nothing), the evolution U|ψ⟩ is performed.\nIf noise is set to something nontrivial, the mixed evolution ε(|ψ⟩⟨ψ|) is performed. Example: noise = (\"amplitude_damping\", (γ = 0.1,)) (amplitude damping channel with decay rate γ = 0.1)\nIf noise = nothing and apply_dag = true, the evolution U|ψ⟩⟨ψ|U† is performed.\n\nIf an MPO ρ is input, there are three possible modes:\n\nBy default (noise = nothing and apply_dag = nothing), the evolution U ρ U† is performed.\nIf noise is set to something nontrivial, the evolution ε(ρ) is performed.\nIf noise = nothing and apply_dag = false, the evolution Uρ is performed.\n\nIf an Observer is provided as input, and circuit is made out of a sequence of layers of gates, performs a measurement of the observables contained in Observer, after the application of each layer.\n\n\n\n\n\n","category":"function"},{"location":"Circuits.html#PastaQ.choimatrix","page":"Circuit Simulator","title":"PastaQ.choimatrix","text":"Compute the Choi matrix Λ  = ε ⊗ 1̂(|ξ⟩⟨ξ|), where |ξ⟩= ⨂ⱼ |00⟩ⱼ+|11⟩ⱼ,  and εis a quantum channel built out of a set of quantum gates and  a local noise model. Returns a MPO withN` tensor having 4 sites indices. \n\n\n\n\n\n","category":"function"},{"location":"Circuits.html#Standard-quantum-circuits-1","page":"Circuit Simulator","title":"Standard quantum circuits","text":"","category":"section"},{"location":"Circuits.html#","page":"Circuit Simulator","title":"Circuit Simulator","text":"randomcircuit(::Int,::Int,::Array)\nqft","category":"page"},{"location":"Circuits.html#PastaQ.qft","page":"Circuit Simulator","title":"PastaQ.qft","text":"qft(N::Int; inverse::Bool = false)\n\nGenerate a list of gates for the quantum fourier transform circuit on N sites.\n\n\n\n\n\n","category":"function"},{"location":"GetSamples.html#Generation-of-measurement-data-1","page":"Generation of measurement data","title":"Generation of measurement data","text":"","category":"section"},{"location":"GetSamples.html#Set-up-1","page":"Generation of measurement data","title":"Set up","text":"","category":"section"},{"location":"GetSamples.html#","page":"Generation of measurement data","title":"Generation of measurement data","text":"randombases\nPastaQ.measurementgates\nrandompreparations\nPastaQ.readouterror!","category":"page"},{"location":"GetSamples.html#PastaQ.randombases","page":"Generation of measurement data","title":"PastaQ.randombases","text":"randombases(N::Int, nbases::Int; local_basis = \"Pauli\")\n\nGenerate nbases measurement bases. By default, each local basis is randomly selected between [\"X\",\"Y\",\"Z\"], with \"Z\" being the default basis where the quantum state is written.\n\n\n\n\n\n","category":"function"},{"location":"GetSamples.html#PastaQ.measurementgates","page":"Generation of measurement data","title":"PastaQ.measurementgates","text":"measurementgates(basis::Vector)\n\nGiven as input a measurement basis, returns the corresponding gate data structure. If the basis is \"Z\", no action is required. If not, a quantum gate corresponding to the given basis rotation is added to the list.\n\nExample:   basis = [\"X\",\"Z\",\"Z\",\"Y\"]\n\n-> gate_list = [(\"basisX\", 1),(\"basisY\", 4)]\n\n\n\n\n\n","category":"function"},{"location":"GetSamples.html#PastaQ.randompreparations","page":"Generation of measurement data","title":"PastaQ.randompreparations","text":"randompreparations(N::Int, nshots::Int;\n                   local_input_state = [\"X+\",\"X-\",\"Y+\",\"Y-\",\"Z+\",\"Z-\"],\n                   ndistinctstates = nothing)\n\nGenerate nshots input states to a quantum circuit. By default, each single-qubit state is randomly selected between the 6 eigenstates of the Pauli matrices, [\"X+\",\"X-\",\"Y+\",\"Y-\",\"Z+\",\"Z-\"]. If ndistinctstates is provided, the output consist of numprep different input states, each being repeated nshots÷ndistinctstates times.\n\n\n\n\n\n","category":"function"},{"location":"GetSamples.html#PastaQ.readouterror!","page":"Generation of measurement data","title":"PastaQ.readouterror!","text":"readouterror!(measurement::Union{Vector, Matrix}, p1given0, p0given1)\n\nAdd readout error to a single projective measurement.\n\nArguments:\n\nmeasurement: bit string of projective measurement outcome\np1given0: readout error probability 0 -> 1\np0given1: readout error probability 1 -> 0\n\n\n\n\n\n","category":"function"},{"location":"GetSamples.html#Data-generation-1","page":"Generation of measurement data","title":"Data generation","text":"","category":"section"},{"location":"GetSamples.html#","page":"Generation of measurement data","title":"Generation of measurement data","text":"PastaQ.getsamples!\ngetsamples","category":"page"},{"location":"GetSamples.html#PastaQ.getsamples!","page":"Generation of measurement data","title":"PastaQ.getsamples!","text":"getsamples!(M::Union{MPS,MPO};\n            readout_errors = (p1given0 = nothing,\n                              p0given1 = nothing))\n\nGenerate a single projective measurement in the MPS/MPO reference basis. If readout_errors is non-trivial, readout errors with given probabilities are applied to the measurement outcome.\n\n\n\n\n\n","category":"function"},{"location":"GetSamples.html#PastaQ.getsamples","page":"Generation of measurement data","title":"PastaQ.getsamples","text":"getsamples(T::ITensor, nshots::Int)\n\nGenerate nshots projective measurements for an input quantum state T, which can either be a wavefunction or density matrix (dense).\n\n\n\n\n\nPastaQ.getsamples!(M::Union{MPS,MPO}, nshots::Int; kwargs...)\n\nPerform nshots projective measurements of a wavefunction  |ψ⟩ or density operator ρ in the MPS/MPO reference basis.  Each measurement consists of a binary vector σ = (σ₁,σ₂,…),  drawn from the probabilty distribution:\n\nP(σ) = |⟨σ|ψ⟩|²  :  if M = ψ is MPS\nP(σ) = ⟨σ|ρ|σ⟩   :  if M = ρ is MPO\n\n\n\n\n\ngetsamples(M::Union{MPS,MPO,ITensor}, bases::Matrix; kwargs...)\n\nGenerate a dataset of measurements acccording to a set of input bases, performing nshots measurements per basis.  For a single measurement, Û is the depth-1  local circuit rotating each qubit, the  data-point σ = (σ₁,σ₂,…) is drawn from the probability distribution:\n\nP(σ) = |⟨σ|Û|ψ⟩|²    :  if M = ψ is MPS \nP(σ) = <σ|Û ρ Û†|σ⟩  :  if M = ρ is MPO   \n\n\n\n\n\n","category":"function"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"(Image: alt text)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"(Image: Tests) (Image: codecov) (Image: ) (Image: ) (Image: License) (Image: website) (Image: arXiv)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"PLEASE NOTE THIS IS PRE-RELEASE SOFTWARE","category":"page"},{"location":"index.html#PastaQ.jl:-design-and-benchmarking-quantum-hardware-1","page":"Introduction","title":"PastaQ.jl: design and benchmarking quantum hardware","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"PastaQ.jl is a Julia software toolbox providing a range of computational methods for quantum computing applications. Some examples are the simulation of quancum circuits, the design of quantum gates, noise characterization and performance benchmarking. PastaQ relies on tensor-network representations of quantum states and processes, and borrows well-refined techniques from the field of machine learning and data science, such as probabilistic modeling and automatic differentiation.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"(Image: alt text)","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"index.html#Install-1","page":"Introduction","title":"Install","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The PastaQ package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"julia> ]\n\npkg> add PastaQ","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"PastaQ.jl relies on the following packages: ITensors.jl for low-level tensor-network algorithms, Optimisers.jl for stochastic optimization methods, Zygote.jl for automatic differentiation, and Observers.jl for tracking/recording metrics and observables. Please note that right now, PastaQ.jl requires that you use Julia v1.6 or later. ","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"index.html#Documentation-1","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"STABLE –  documentation of the most recently tagged version.\nDEVEL – documentation of the in-development version.","category":"page"},{"location":"index.html#Examples-1","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"We briefly showcase some of the functionalities provided by PastaQ.jl. For more in-depth discussion, please refer to the tutorials folder.","category":"page"},{"location":"index.html#Simulating-quantum-circuits-1","page":"Introduction","title":"Simulating quantum circuits","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"The vast majority of tasks related to designing and benchmarking quantum computers relies on the capability of simulating quantum circuits, built out of a collection of elementary quantum gates. In PastaQ, a quantum gates is described by a data structure g = (\"gatename\", support, params), consisting of a gate identifier gatename (a String), a support (an Int for single-qubit gates or a Tuple for multi-qubit gates), and a set of gate parameters, such as rotations angles, whenever needed. A comprehensive set of elementary gates is provided, including Pauli operations, phase and T gates, single-qubit rotations, controlled gates, Toffoli gate and others. Additional user-specific gates can be easily added to this collection. Once a circuit is defined, it can be executed using the runcircuit function:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using PastaQ\n\n# a quantum circuit in PastaQ\ngates = [(\"X\" , 1),                              # Pauli X on qubit 1\n         (\"CX\", (1, 3)),                         # Controlled-X on qubits [1,3]\n         (\"Rx\", 2, (θ = 0.5,)),                  # Rotation of θ around X\n         (\"Rn\", 3, (θ = 0.5, ϕ = 0.2, λ = 1.2)), # Arbitrary rotation with angles (θ,ϕ,λ)\n         (\"√SWAP\", (3, 4)),                      # Sqrt Swap on qubits [2,3]\n         (\"T\" , 4)]                              # T gate on qubit 4\n         \n# run the circuit\nψ = runcircuit(gates)\n# returns the MPS at the output of the quantum circuit: `|ψ⟩ = Û|0,0,…,0⟩`\n# first the gate (\"X\" , 1) is applied, then (\"CX\", (1, 3)), etc.\n\n# ------------------------------------------------------------------\n# Output:\n#  ITensors.MPS\n#  [1] ((dim=2|id=456|\"Qubit,Site,n=1\"), (dim=1|id=760|\"Link,n=1\"))\n#  [2] ((dim=1|id=760|\"Link,n=1\"), (dim=2|id=613|\"Qubit,Site,n=2\"), (dim=1|id=362|\"Link,n=1\"))\n#  [3] ((dim=2|id=9|\"Qubit,Site,n=3\"), (dim=2|id=357|\"Link,n=1\"), (dim=1|id=362|\"Link,n=1\"))\n#  [4] ((dim=2|id=980|\"Qubit,Site,n=4\"), (dim=2|id=357|\"Link,n=1\"))","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"In this next example, we create a circuit to prepare the GHZ state, and sample projective measurements in the computational basis. We then execture the circuit in the presence of noise, where a local noise channel is applied to each gate. A noise model is described as noisemodel = (\"noisename\", (noiseparams...)), in which case it is applied to each gate identically. To distinguish between one- and two-qubit gates, for example, the following syntax can be used: noisemodel = (1 => noise1, 2 => noise2). For more sophisticated noise models (such as gate-dependent noise), please refer to the documentation. ","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using PastaQ\nusing ITensors\n\n# number of qubits\nn = 20\n\n# manually create a circuit to prepare GHZ state,\n# or use built-in call `circuit = ghz(n)` \ncircuit = Tuple[(\"H\", 1)]\nfor j in 1:n-1\n  push!(circuit, (\"CX\", (j, j+1)))\nend\n\n# run the circuit to obtain the output MPS\nhilbert = qubits(n)\nψ = runcircuit(hilbert, circuit)\n\n\n# sample projective measurements in the computational basis\n@show getsamples(ψ, 5)\n\n# define a noise model with different error rates for\n# one- and two-qubit gates\nnoisemodel = (1 => (\"depolarizing\", (p = 0.01,)), \n              2 => (\"depolarizing\", (p = 0.05,)))\n\n# run a noisy circuit\nρ = runcircuit(hilbert, circuit; noise = noisemodel)\n@show fidelity(ψ, ρ)\n@show getsamples(ρ, 5)\n\n# quantum processes can also be obtained.\n# unitary MPO\nU = runcircuit(circuit; process = true)\n# Choi matrix\nΛ = runcircuit(circuit; process = true, noise = noisemodel)\n\n# ------------------------------------------------------------------\n# Output:\n#  5×20 Matrix{Int64}:\n#  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n#  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n#  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n#  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n#  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1\n# \n#  fidelity(ψ, ρ) = 0.40840853095498975\n# \n#  5×20 Matrix{Int64}:\n#  1  1  1  1  1  1  0  0  0  0  0  0  1  0  0  0  1  1  1  1\n#  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n#  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1\n#  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  1  1  1  1\n#  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"There is a number of built-in circuits available, one examples being random circuits. In the following, we generate a one-dimensional random quantum circuits built out with a brick-layer geometry of alternative CX gates and layers of random single-qubit rotations:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"n = 100 \ndepth = 20\ncircuit = randomcircuit(n; depth = depth, \n                           twoqubitgates = \"CX\", \n                           onequbitgates = \"Rn\")\n@time ψ = runcircuit(circuit; cutoff = 1e-10)\n@show maxlinkdim(ψ)\n# ------------------------------------------------------------------\n# Output:\n#  89.375383 seconds (5.25 M allocations: 64.781 GiB, 9.98% gc time)\n#  maxlinkdim(ψ) = 908","category":"page"},{"location":"index.html#Variational-quantum-eingensolver-1","page":"Introduction","title":"Variational quantum eingensolver","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"We show how to perform a ground state search of a many-body hamiltonian H using the variational quantum eigensolver (VQE). The VQE algorithm, based on the variational principle, consists of an iterative optimization of an objective function langle psi(theta)Hpsi(theta)ranglelanglepsi(theta)psi(theta)rangle, where psi(theta)rangle = U(theta)0rangle is the output wavefunction of a parametrized quantum circuit U(theta). ","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"In the following example, we consider a quantum Ising model with 10 spins, and perform the optimization by leveraging Automatic Differentiation techniques (AD), provided by the package Zygote.jl. Specifically, we build a variational circuit using built-in circuit-contruction functions, and optimize the expectation value of the Hamiltonian using a gradient-based approach and the LBFGS optimizer. The gradients are evaluated through AD, providing a flexible interface in defining custom variational circuit ansatze.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using ITensors\nusing PastaQ\nusing Printf\nusing OptimKit\nusing Zygote\n\nN = 10   # number of qubits\nJ = 1.0  # Ising exchange interaction\nh = 0.5  # transverse magnetic field\n\n# Hilbert space\nhilbert = qubits(N)\n\n# define the Hamiltonian\nos = OpSum()\nfor j in 1:N-1\n  os .+= (-J, \"Z\",j,\"Z\",j+1)\n  os .+= (-h, \"X\", j)\nend\nos .+= (-h, \"X\",N)\n\n# build MPO \"cost function\"\nH = MPO(os, hilbert)\nEdmrg = -9.7655034665\n@printf(\"Exact energy from DMRG: %.8f\\n\", Edmrg)\n\n# layer of single-qubit Ry gates\nRylayer(N, θ) =\n  [(\"Ry\", j, (θ = θ[j],)) for j in 1:N]\n\n# brick-layer of CX gates\nCXlayer(N,Π) =\n  isodd(Π) ? [(\"CX\", (j, j+1)) for j in 1:2:N-1] :\n             [(\"CX\", (j, j+1)) for j in 2:2:N-1]\n\n# variational ansatz\nfunction variationalcircuit(N, depth, θ⃗)\n  circuit = Tuple[]\n  for d in 1:depth\n    circuit = vcat(circuit, CXlayer(N, d))\n    circuit = vcat(circuit, Rylayer(N, θ⃗[d]))\n  end\n  return circuit\nend\n\ndepth = 20\nψ = productstate(hilbert)\n\n# cost function\nfunction loss(θ⃗)\n  circuit = variationalcircuit(N, depth, θ⃗)\n  U = buildcircuit(ψ, circuit)\n  return rayleigh_quotient(H, U, ψ; cutoff = 1e-8)\nend\n\n# initialize parameters\nθ⃗₀ = [2π .* rand(N) for _ in 1:depth]\n\n# run VQE using BFGS optimization\noptimizer = LBFGS(maxiter = 500, verbosity=2)\nloss_n_grad(x) = (loss(x), convert(Vector, loss'(x)))\nθ⃗, fs, gs, niter, normgradhistory = optimize(loss_n_grad, θ⃗₀,  optimizer)\n@printf(\"Relative error: %.3E\", abs(Edmrg - fs[end]) / abs(Edmrg))\n\n# ------------------------------------------------------------------\n# Output:\n#  Exact energy from DMRG: -9.76550347\n# \n#  [ Info: LBFGS: initializing with f = -0.182090597122, ‖∇f‖ = 2.3297e+00\n#  [ Info: LBFGS: iter    1: f = -2.157995740330, ‖∇f‖ = 2.4305e+00, α = 1.00e+00, m = 0, nfg = 1\n#  [ Info: LBFGS: iter    2: f = -2.397853058857, ‖∇f‖ = 4.5561e+00, α = 1.00e+00, m = 1, nfg = 1\n#  [ Info: LBFGS: iter    3: f = -4.141376142741, ‖∇f‖ = 3.0358e+00, α = 1.00e+00, m = 2, nfg = 1\n#  [ Info: LBFGS: iter    4: f = -4.850744631864, ‖∇f‖ = 2.7316e+00, α = 1.00e+00, m = 3, nfg = 1\n#  [ Info: LBFGS: iter    5: f = -5.522683055280, ‖∇f‖ = 2.3480e+00, α = 1.00e+00, m = 4, nfg = 1\n#  ...\n#  [ Info: LBFGS: iter  498: f = -9.764686918396, ‖∇f‖ = 9.0752e-04, α = 1.00e+00, m = 8, nfg = 1\n#  [ Info: LBFGS: iter  499: f = -9.764687006358, ‖∇f‖ = 1.1905e-03, α = 1.00e+00, m = 8, nfg = 1\n#  Relative error: 8.360E-05","category":"page"},{"location":"index.html#Monitored-quantum-circuits-1","page":"Introduction","title":"Monitored quantum circuits","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"In this example we simulate a monitored quantum circuit, a circuit composed by entangling unitaries and probabilistic local projective measurements, with a rate p. The circuit has a brick-layer structure, where each layer consists of nearest-neighbor two-qubit random unitaries, followed by a layer of randomly-placed projective measurements in the computational basis. In the limit of p=0, the system displays a scrambling dynamics, exhibiting a volume-law entanglement entropy. When p grows large, the competition between the entangling unitaries and the (disentangling) projective measurements generates can induce an ''entanglement phase transition\" at a critical rate p_c, separating a volume law phase (low p) from an area-law phase (high p).","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"using PastaQ\nusing ITensors\nusing Printf\nusing LinearAlgebra\nusing StatsBase: mean, sem \n\nimport PastaQ: gate\n\n# define the two measurement projectors\ngate(::GateName\"Π0\") =\n  [1 0\n   0 0]\ngate(::GateName\"Π1\") =\n  [0 0\n   0 1]\n\n# compute the Von Neumann entanglement entropy at the center bond \n# of a linear chain of qubits\nfunction entanglemententropy(ψ₀::MPS)\n  ψ = normalize!(copy(ψ₀))\n  N = length(ψ)\n  bond = N ÷ 2\n  orthogonalize!(ψ, bond)\n\n  row_inds = (linkind(ψ, bond - 1), siteind(ψ, bond))\n  u, s, v = svd(ψ[bond], row_inds)\n\n  S = 0.0\n  for n in 1:dim(s, 1)\n    λ = s[n, n]^2\n    S -= λ * log(λ + 1e-20)\n  end\n  return S\nend\n\n# build a brick-layer circuit of random unitaries\nfunction entangling_layer(N::Int)\n  layer_odd  = randomlayer(\"RandomUnitary\",[(j,j+1) for j in 1:2:N-1])\n  layer_even = randomlayer(\"RandomUnitary\",[(j,j+1) for j in 2:2:N-1])\n  return [layer_odd..., layer_even...]\nend\n\n# perform a projective measurement in the computational basis\n# at a given site\nfunction projective_measurement!(ψ₀::MPS, site::Int)\n  ψ = orthogonalize!(ψ₀, site)\n  ϕ = ψ[site]\n  # 1-qubit reduced density matrix\n  ρ = prime(ϕ, tags=\"Site\") * dag(ϕ)\n  # Outcome probabilities\n  prob = real.(diag(array(ρ)))\n  # Sample\n  σ = (rand() < prob[1] ? 0 : 1)\n  # Projection\n  ψ = runcircuit(ψ, (\"Π\"*\"$(σ)\", site))\n  normalize!(ψ)\n  ψ₀[:] = ψ\n  return ψ₀\nend\n\n# compute average Von Neumann entropy for an ensemble of random circuits\n# for a fixed local measurement probability rate `p`\nfunction monitored_circuits(circuits::Vector{<:Vector}, p::Float64)\n  svn = []\n  N = nqubits(circuits[1])\n  for circuit in circuits\n    # initialize state ψ = |000…⟩\n    ψ = productstate(N)\n    # sweep over layers\n    for layer in circuit\n      # apply entangling unitary\n      ψ = runcircuit(ψ, layer; cutoff = 1e-8)\n      # perform measurements\n      for j in 1:N\n        p > rand() && projective_measurement!(ψ, j)\n      end\n    end\n    push!(svn, entanglemententropy(ψ))\n  end\n  return svn\nend\n\nlet\n  Random.seed!(1234)\n  N = 10        # number of qubits\n  depth = 100   # circuit's depth\n  ntrials = 50  # number of random trials\n\n  # generate random circuits\n  circuits = [[entangling_layer(N) for _ in 1:depth] for _ in 1:ntrials]\n\n  # loop over projective measurement probability (per site)\n  for p in 0.0:0.02:0.2\n    t = @elapsed svn = monitored_circuits(circuits, p)\n    @printf(\"p = %.2f  S(ρ) = %.5f ± %.1E\\t(elapsed = %.2fs)\\n\", p, mean(svn), sem(svn), t)\n  end\nend\n\n# ------------------------------------------------------------------\n# Output:\n#  p = 0.00  S(ρ) = 2.96398 ± 2.0E-03\t(elapsed = 75.53s)\n#  p = 0.02  S(ρ) = 2.64681 ± 4.1E-02\t(elapsed = 31.23s)\n#  p = 0.04  S(ρ) = 2.42949 ± 5.8E-02\t(elapsed = 31.73s)\n#  p = 0.06  S(ρ) = 2.24704 ± 5.0E-02\t(elapsed = 30.99s)\n#  p = 0.08  S(ρ) = 1.99610 ± 6.3E-02\t(elapsed = 32.02s)\n#  p = 0.10  S(ρ) = 1.95011 ± 6.3E-02\t(elapsed = 32.27s)\n#  p = 0.12  S(ρ) = 1.72640 ± 5.6E-02\t(elapsed = 31.29s)\n#  p = 0.14  S(ρ) = 1.66021 ± 5.8E-02\t(elapsed = 31.75s)\n#  p = 0.16  S(ρ) = 1.30065 ± 5.6E-02\t(elapsed = 32.44s)\n#  p = 0.18  S(ρ) = 1.34038 ± 6.4E-02\t(elapsed = 33.34s)\n#  p = 0.20  S(ρ) = 1.12428 ± 6.0E-02\t(elapsed = 34.35s)","category":"page"},{"location":"index.html#Citation-1","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"If you use PastaQ.jl in your work, for now please consider citing the Github page:","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"@misc{pastaq,\n    title={\\mbox{PastaQ}: A Package for Simulation, Tomography and Analysis of Quantum Computers},\n    author={Giacomo Torlai and Matthew Fishman},\n    year={2020},\n    url={https://github.com/GTorlai/PastaQ.jl/}\n}","category":"page"},{"location":"index.html#Research-papers-using-PastaQ-1","page":"Introduction","title":"Research papers using PastaQ","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"If you used PastaQ.jl and your paper does not appear in this list, please let us know at info@pastaq.org.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"2022 </br> - 2203.04948 Fragile boundaries of tailored surface codes, O Higgott, TC Bohdanowicz, A Kubica, ST Flammia, ET Campbell.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"2021 </br> - 2106.12627 Provably efficient machine learning for quantum many-body problems, H-Y Huang, R Kueng, G Torlai, VV Albert, J Preskill. </br> - 2106.03769 Measurement-induced phase transition in trapped-ion circuits, S Czischek, G Torlai, S Ray, R Islam, RG Melko, Phys. Rev. A 104, 062405. </br> - 2101.11099 How To Use Neural Networks To Investigate Quantum Many-Body Physics, J Carrasquilla and G Torlai, PRX Quantum, 2, 040201.","category":"page"},{"location":"index.html#","page":"Introduction","title":"Introduction","text":"2020 </br> - 2009.01760 Classical variational simulation of the Quantum Approximation Optimization Algorithm, M Medvidovic and G Carleo, Nature Communication, 7, 101.</br> - 2006.02424 Quantum process tomography with unsupervised learning and tensor networks, G Torlai, CJ Wood, A Acharya, G Carleo, J Carrasquilla, L Aolita. </br>","category":"page"},{"location":"RandomStates.html#Random-states-1","page":"Random states","title":"Random states","text":"","category":"section"},{"location":"RandomStates.html#Quantum-states-1","page":"Random states","title":"Quantum states","text":"","category":"section"},{"location":"RandomStates.html#","page":"Random states","title":"Random states","text":"randomstate","category":"page"},{"location":"RandomStates.html#PastaQ.randomstate","page":"Random states","title":"PastaQ.randomstate","text":"randomstate(N::Int64; kwargs...)\n\nrandomstate(ElT::Type{<: Number}, N::Int64; kwargs...)\n\nGenerates a random quantum state of N qubits.\n\nOptionally, specify an element type, such as randomstate(Float64, 10) for a random real state (by default it is complex).\n\nArguments\n\nN: number of qubits\nmixed: if false (default), generate a random MPS; if true, generates a random LPDO\nalg: algorithm used for initialization: \"rand\" initializes random tensor elements;  \"circuit\" initializes with a random quantum circuit (MPS only).\nσ: size of the 0-centered uniform distribution in alg=\"rand\". \nχ: bond dimension of the MPS/LPDO\n'ξ`: kraus dimension (LPDO)\nnormalize: if true, return normalized state\n\n\n\n\n\nrandomstate(M::Union{MPS,MPO,LPDO}; kwargs...)\n\nGenerate a random state with same Hilbert space (i.e. site indices) of a reference state M.\n\n\n\n\n\n","category":"function"},{"location":"RandomStates.html#Quantum-channels-1","page":"Random states","title":"Quantum channels","text":"","category":"section"},{"location":"RandomStates.html#","page":"Random states","title":"Random states","text":"randomprocess","category":"page"},{"location":"RandomStates.html#PastaQ.randomprocess","page":"Random states","title":"PastaQ.randomprocess","text":"randomprocess(N::Int64; kwargs...)\n\nrandomprocess(ElT::Type{<: Number}, N::Int64; kwargs...)\n\nGenerates a random quantum procecss of N qubits.\n\nOptionally choose the element type with calls like randomprocess(Float64, 10) (by default it is complex).\n\nArguments\n\nN: number of qubits\nmixed: if false (default), generates a random MPO; if true, generates a random LPDO.\nalg: initialization criteria, set to \"randompars\" (see randomstate).\nσ: size of the 0-centered uniform distribution in alg=\"rand\". \nχ: bond dimension of the MPO/LPDO.\n'ξ`: kraus dimension (LPDO).\n\n\n\n\n\nrandomprocess(M::Union{MPS,MPO}; kwargs...)\n\nGenerate a random process with same Hilbert space (i.e. input and output indices)of a reference process M.\n\n\n\n\n\n","category":"function"}]
}
