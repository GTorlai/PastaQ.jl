<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum circuits · PastaQ.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="PastaQ.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PastaQ.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="quantumstates.html">Quantum states</a></li><li class="is-active"><a class="tocitem" href="quantumcircuits.html">Quantum circuits</a><ul class="internal"><li><a class="tocitem" href="#Built-in-circuits-1"><span>Built-in circuits</span></a></li><li><a class="tocitem" href="#Random-circuits-1"><span>Random circuits</span></a></li><li><a class="tocitem" href="#Executing-quantum-circuits-1"><span>Executing quantum circuits</span></a></li></ul></li><li><a class="tocitem" href="measurements.html">Measurements</a></li><li><a class="tocitem" href="quantumtomography.html">Quantum tomography</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="examples/optimal-coherent-control.html">Optimal coherent control</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="quantumcircuits.html">Quantum circuits</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="quantumcircuits.html">Quantum circuits</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GTorlai/PastaQ.jl/blob/master/docs/src/quantumcircuits.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-Circuits-1"><a class="docs-heading-anchor" href="#Quantum-Circuits-1">Quantum Circuits</a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuits-1" title="Permalink"></a></h1><h2 id="Built-in-circuits-1"><a class="docs-heading-anchor" href="#Built-in-circuits-1">Built-in circuits</a><a class="docs-heading-anchor-permalink" href="#Built-in-circuits-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PastaQ.ghz" href="#PastaQ.ghz"><code>PastaQ.ghz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ghz(n::Int)</code></pre><p>Generate a list of gates for the GHZ state.</p><p><span>$|\psi\rangle = (|0,0,\dots,0\rangle + |1,1,\dots,1\rangle)/\sqrt{2}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/circuits.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PastaQ.qft" href="#PastaQ.qft"><code>PastaQ.qft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">qft(n::Int; inverse::Bool = false)</code></pre><p>Generate a list of gates for the quantum fourier transform circuit on <span>$n$</span> qubits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/circuits.jl#L23-L27">source</a></section></article><h4 id="Assembling-circuits-1"><a class="docs-heading-anchor" href="#Assembling-circuits-1">Assembling circuits</a><a class="docs-heading-anchor-permalink" href="#Assembling-circuits-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="PastaQ.gatelayer" href="#PastaQ.gatelayer"><code>PastaQ.gatelayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gatelayer(gatename::AbstractString, n::Int; kwargs...)</code></pre><p>Create a uniform layer containing <code>n</code> identical quantum gates, idenfitied by <code>gatename</code>. If additional parameteres are provided, they are identically added to all gates.</p><pre><code class="language-julia">gatelayer(&quot;H&quot;,3)
# 3-element Vector{Tuple{String, Int64}}:
#  (&quot;H&quot;, 1)
#  (&quot;H&quot;, 2)
#  (&quot;H&quot;, 3)

gatelayer(&quot;X&quot;,1:2:5)
# 3-element Vector{Tuple{String, Int64}}:
#  (&quot;X&quot;, 1)
#  (&quot;X&quot;, 3)
#  (&quot;X&quot;, 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/circuits.jl#L75-L94">source</a></section><section><div><pre><code class="language-none">gatelayer(gatename::AbstractString, bonds::Vector{Vector{Int}}; kwargs...)</code></pre><p>Create a uniform layer of multi-qubit gates over a set of <code>bonds</code>.</p><pre><code class="language-julia">gatelayer(&quot;CX&quot;, [(j,j+1), j=1:2:5])
# 3-element Vector{Tuple{String, Tuple{Int64, Int64}}}:
#  (&quot;CX&quot;, (1, 2))
#  (&quot;CX&quot;, (3, 4))
#  (&quot;CX&quot;, (5, 6))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/circuits.jl#L103-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PastaQ.randomlayer" href="#PastaQ.randomlayer"><code>PastaQ.randomlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomlayer(
  gatename::AbstractString, 
  support::Union{Int, Vector{&lt;:Tuple}, AbstractRange}; 
  rng = Random.GLOBAL_RNG,
  kwargs...
)</code></pre><p>Generate a random layer built out of a set one or two qubit gates If <code>support::Int = n</code>, generates  <span>$n$</span> single-qubit gates <code>gatename</code>. If <code>support::Vector=bonds</code>, generates a set of two-qubit gates on the couplings contained in <code>support</code>.</p><pre><code class="language-julia">randomlayer(&quot;Ry&quot;, 3)
# 3-element Vector{Any}:
#  (&quot;Ry&quot;, 1, (θ = 0.5029516521736083,))
#  (&quot;Ry&quot;, 2, (θ = 2.5324545964433693,))
#  (&quot;Ry&quot;, 3, (θ = 2.0510824561219523,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/circuits.jl#L132-L150">source</a></section><section><div><pre><code class="language-none">randomlayer(
  gatenames::Vector{&lt;:AbstractString},
  support::Union{Vector{&lt;:Int}, AbstractRange, Vector{&lt;:Tuple}};
  rng=Random.GLOBAL_RNG,
  weights::Union{Nothing,Vector{Float64}} = ones(length(gatenames)) / length(gatenames),
  kwargs...,
)</code></pre><p>Generate a random layer built out of one or two qubit gates, where <code>gatenames</code> is a set of possible gates to choose from. By default, each single gate is sampled uniformaly over this set. If <code>weights</code> are provided, each gate is sampled accordingly.</p><pre><code class="language-julia">randomlayer([&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;], 3)
# 3-element Vector{Any}:
#  (&quot;Y&quot;, 1)
#  (&quot;Y&quot;, 2)
#  (&quot;X&quot;, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/circuits.jl#L171-L190">source</a></section></article><h2 id="Random-circuits-1"><a class="docs-heading-anchor" href="#Random-circuits-1">Random circuits</a><a class="docs-heading-anchor-permalink" href="#Random-circuits-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PastaQ.randomcircuit" href="#PastaQ.randomcircuit"><code>PastaQ.randomcircuit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomcircuit(
  coupling_sequence::Vector;
  depth::Int = 1,
  twoqubitgates::Union{String,Vector{String}}=&quot;RandomUnitary&quot;,
  onequbitgates::Union{Nothing,String,Vector{String}}=nothing,
  layered::Bool=true,
  rng=Random.GLOBAL_RNG)</code></pre><p>Build a circuit with given <code>depth</code>, where each layer consists of a set of  two-qubit gates applied on pairs of qubits in according to a set of <code>coupling_sequences</code>. Each layer also contains <span>$n$</span> single-qubit gates. IN both cases, the chosen gates are passed as keyword arguments <code>onequbitgates</code> and <code>twoqubitgates</code>. </p><p>The default configurations consists of two-qubit random Haar unitaries, and no single-qubit gates. </p><p>If <code>layered = true</code>, the object returned in a <code>Vector</code> of circuit layers, rather than the full collection  of quantum gates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/circuits.jl#L215-L230">source</a></section><section><div><pre><code class="language-none">randomcircuit(n::Int; kwargs...)</code></pre><p>One-dimensional random quantum circuit:</p><pre><code class="language-julia">randomcircuit(4; depth = 2, twoqubitgates = &quot;CX&quot;, onequbitgates = &quot;Ry&quot;)
# [(&quot;CX&quot;, (1, 2)), 
#  (&quot;CX&quot;, (3, 4)), 
#  (&quot;Ry&quot;, 1, (θ = 0.52446,)), 
#  (&quot;Ry&quot;, 2, (θ = 3.01059,)), 
#  (&quot;Ry&quot;, 3, (θ = 0.25144,)), 
#  (&quot;Ry&quot;, 4, (θ = 1.93356,))]
# [(&quot;CX&quot;, (2, 3)), 
#  (&quot;Ry&quot;, 1, (θ = 2.15460,)), 
#  (&quot;Ry&quot;, 2, (θ = 2.52480,)), 
#  (&quot;Ry&quot;, 3, (θ = 1.85756,)), 
#  (&quot;Ry&quot;, 4, (θ = 0.02405,))]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/circuits.jl#L266-L284">source</a></section><section><div><pre><code class="language-none">randomcircuit(size::Tuple; rotated::Bool = false, kwargs...)</code></pre><p>Two-dimensional random quantum circuit on a square lattice. If <code>rotated = true</code>, use rotated lattice of 45 degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/circuits.jl#L289-L294">source</a></section></article><h2 id="Executing-quantum-circuits-1"><a class="docs-heading-anchor" href="#Executing-quantum-circuits-1">Executing quantum circuits</a><a class="docs-heading-anchor-permalink" href="#Executing-quantum-circuits-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PastaQ.buildcircuit" href="#PastaQ.buildcircuit"><code>PastaQ.buildcircuit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">buildcircuit(
  hilbert::Vector{&lt;:Index},
  circuit::Union{Tuple, Vector{&lt;:Any}};
  noise::Union{Nothing, Tuple, NamedTuple} = nothing
)
buildcircuit(M::Union{MPS,MPO,ITensor}, args...; kwargs...)</code></pre><p>Compile a circuit from a lazy representation into a vector of <code>ITensor</code>. For example, a gate element of <code>circuit</code>, <code>(&quot;gn&quot;, (i,j))</code> is turned into a rrank-4 tensor corresponding to the <code>i</code> and <code>j</code> element of <code>hilbert</code>.</p><p>If <code>noise</code> is passed, the corresponding Kraus operator are inserted appropriately  after the gates in the circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/runcircuit.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PastaQ.runcircuit" href="#PastaQ.runcircuit"><code>PastaQ.runcircuit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">runcircuit(circuit::Any; kwargs...)</code></pre><p>Execute quantum circuit (see below).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/runcircuit.jl#L48-L52">source</a></section><section><div><pre><code class="language-none">runcircuit(hilbert::Vector{&lt;:Index}, circuit::Tuple; kwargs...)</code></pre><p>Execute quantum circuit on Hilbert space <code>hilbert</code> (see below).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/runcircuit.jl#L60-L64">source</a></section><section><div><pre><code class="language-none">runcircuit(hilbert::Vector{&lt;:Index}, circuit::Vector;
           full_representation::Bool = false,
           process::Bool = false, 
           noise = nothing,
           kwargs...)

runcircuit(M::Union{MPS, MPO, ITensor}, circuit::Union{Tuple, AbstractVector};
           full_representation::Bool = false, noise = nothing, kwargs...)</code></pre><p>Run the circuit corresponding to a list of quantum gates on a system of <span>$n$</span> qubits, with input Hilbert space <code>hilbert</code>. The specific method of this general function is  specified by the keyword arguments <code>process</code> and <code>noise</code>. </p><p>By default (<code>process = false</code> and <code>noise = nothing</code>), <code>runcircuit</code> returns an MPS wavefunction corresponding to the contraction of each quantum gate in <code>circuit</code> with the zero product state</p><div>\[|\psi\rangle = U_M\dots U_2 U_1|0,0,\dots,0\rangle\]</div><p>If <code>process = true</code>, the output is the MPO corresponding to the full unitary circuit:</p><div>\[U = U_M\dots U_2 U_1\]</div><p>If <code>noise</code> is set to a given input noise model (in lazy representation), Kraus operators are added to each gate in the circuit, and the output is the MPO density operator given by the contraction of the noisy circuit with input zero state:</p><div>\[\rho = \mathcal{E}(|0,\dots,0\rangle\langle0,\dots,0|)\]</div><p>Finally, if both <code>noise = ...</code> and <code>proces  = true</code>, the output is the full quantum channel, which we by default represent with its Choi matrix:</p><div>\[\Lambda = (1+\mathcal{E})|\Phi\rangle\langle\Phi|^{\otimes n}\]</div><p>If <code>full_representation = true</code>, the contraction is performed without approximation, leading to an output object whose size scales exponentiall with <span>$n$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/runcircuit.jl#L69-L113">source</a></section><section><div><pre><code class="language-none">runcircuit(
  M::Union{MPS, MPO, ITensor},
  circuit::Vector{&lt;:Vector{&lt;:ITensor}};
  (observer!)=nothing,
  move_sites_back_before_measurements::Bool=false,
  noise = nothing,
  outputlevel = 1,
  outputpath = nothing,
  savestate  = false,
  print_metrics = [],
  kwargs...)</code></pre><p>Apply a quantum circuit to an input state <code>M</code>, where the circuit is built out of a  sequence of layers of quantum gates. The input state may be an MPS wavefunction <span>$|\psi\rangle$</span>, an MPO density operator <span>$ρ$</span> (or unitary operator <span>$U$</span>), etc.</p><p>By feeding a &quot;layered&quot; circuit, we can enable measurement and keep track of metrics as a function of the circuit&#39;s depth. </p><p>Other than the keyword arguments of the high-level interface, here we can provide:</p><ul><li><code>(observer!)</code>: observer object (from Observers.jl).</li><li><code>outputlevel = 1</code>: amount of printing during calculation.</li><li><code>outputpath = nothing</code>: if set, save observer on file.</li><li><code>savestate = false</code>: if <code>true</code>, save the <code>MPS/MPO</code> on file.</li><li><code>print_metrics = []</code>: the metrics in the <code>observed</code> to print at each depth.`</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/runcircuit.jl#L159-L185">source</a></section><section><div><pre><code class="language-none">runcircuit(
  M::Union{MPS,MPO},
  circuit_tensors::Vector{&lt;:ITensor};
  apply_dag=nothing,
  cutoff=1e-15,
  maxdim=10_000,
  svd_alg=&quot;divide_and_conquer&quot;,
  move_sites_back::Bool=true,
  kwargs...)</code></pre><p>Apply a set of &quot;gate&quot; tensors (alredy in the form of <code>ITensor</code>) to an input  state <code>M</code>, with options:</p><ul><li><code>apply_dag = nothing</code>: whether to perform conjugate evolution.</li><li><code>cutoff = 1e-15</code>: truncation cutoff in SVD.</li><li><code>maxdim = 10_000</code>: maximum bond dimension at SVD trunctions.</li><li><code>svd_alg = &quot;divide_and_conquer&quot;</code>: SVD algorithm (see ITensors.jl).</li><li><code>move_sites_back = true</code>: move sites back after long-range gate.</li></ul><p>By default, <code>apply_dag = nothing</code> and the interface is dictated by the input state,  and whether or not the vector of <code>ITensor</code> containins rank-3 noisy tensors (i.e. Kraus operators).</p><p>For an input MPS <span>$|\psi_0\rangle$</span>, with a unitary circuit, the output is </p><div>\[|\psi\rangle = U_M\dots U_2 U_1|\psi_0\rangle\]</div><p>while for noisy circuits:</p><div>\[\rho = \mathcal{E}(|\psi_0\rangle\langle\psi_0|)\]</div><p>For an input MPO <span>$\rho_0$</span>, the output is</p><div>\[\rho = U_M\dots U_2 U_1 \rho_0 U^\dagger_1 U^\dagger_2,\dots,U^\dagger_M\]</div><p>for unitary circuits, and <span>$\rho = \mathcal{E}(\rho_0)$</span> for noisy circuits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/runcircuit.jl#L256-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PastaQ.choimatrix" href="#PastaQ.choimatrix"><code>PastaQ.choimatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">choimatrix(circuit::Vector{&lt;:Any}; kwargs...) = 
choimatrix(sites::Vector{&lt;:Index}, circuit::Vector{&lt;:Any}; kwargs...)
choimatrix(sites::Vector{&lt;:Index}, circuit_tensors::Vector{&lt;:ITensor};
           full_representation = false,kwargs...)</code></pre><p>Compute the Choi matrix for a noisy channel</p><div>\[\Lambda = (1+\mathcal{E})|\Phi\rangle\langle\Phi|^{\otimes n}\]</div><p>If <code>full_representation = true</code>, the contraction is performed without approximation, leading to an output object whose size scales exponentiall with <span>$n$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GTorlai/PastaQ.jl/blob/11d9996a8019dd69f0154581bae170acddc3e805/src/circuits/runcircuit.jl#L403-L417">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="quantumstates.html">« Quantum states</a><a class="docs-footer-nextpage" href="measurements.html">Measurements »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 2 April 2022 16:13">Saturday 2 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
